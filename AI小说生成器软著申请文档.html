<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI小说生成器软件著作权申请文档</title>
    <style>
        body {
            font-family: 'SimSun', serif;
            line-height: 1.8;
            margin: 2cm;
            text-align: justify;
            counter-reset: page;
            color: #333;
            background-color: #f9f9f9;
        }
        h1, h2, h3, h4 {
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
            color: #2c3e50;
        }
        h1 {
            font-size: 24pt;
            text-align: center;
            margin-top: 2cm;
            margin-bottom: 1cm;
            color: #1a365d;
        }
        h2 {
            font-size: 18pt;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
            color: #2980b9;
        }
        h3 {
            font-size: 16pt;
            color: #3498db;
            border-left: 4px solid #3498db;
            padding-left: 10px;
        }
        h4 {
            font-size: 14pt;
            color: #2c3e50;
        }
        p {
            text-indent: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }
        .toc {
            margin: 2cm 0;
            background: #f5f5f5;
            padding: 1em;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .toc-item {
            display: block;
            margin: 8px 0;
            text-decoration: none;
            color: #2c3e50;
        }
        .toc-item:hover {
            color: #3498db;
        }
        .toc-h2 {
            margin-left: 0;
            font-weight: bold;
        }
        .toc-h3 {
            margin-left: 2em;
        }
        .toc-h4 {
            margin-left: 4em;
        }
        .page-break {
            page-break-after: always;
            height: 0;
            margin: 0;
            padding: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1em 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1em auto;
            border-radius: 5px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        .centered {
            text-align: center;
        }
        .code {
            font-family: 'Courier New', monospace;
            background-color: #f5f5f5;
            padding: 1em;
            border: 1px solid #ddd;
            border-radius: 5px;
            white-space: pre-wrap;
            overflow-x: auto;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            font-size: 0.9em;
        }
        .page {
            background-color: white;
            padding: 2cm;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 1cm;
            counter-increment: page;
            border-radius: 5px;
        }
        .highlight {
            background-color: #fffacd;
            padding: 0.5em;
            border-left: 4px solid #ffd700;
        }
        .note {
            background-color: #e8f4f8;
            padding: 1em;
            border-left: 4px solid #3498db;
            margin: 1em 0;
        }
        .warning {
            background-color: #ffedcc;
            padding: 1em;
            border-left: 4px solid #f39c12;
            margin: 1em 0;
        }
        .svg-container {
            width: 100%;
            margin: 2em auto;
            text-align: center;
        }
        @page {
            margin: 2cm;
            @bottom-right {
                content: counter(page);
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <h1>AI小说生成器</h1>
        <h2 class="centered">软件著作权申请文档</h2>
        <p class="centered">版本：4.0.0</p>
        <p class="centered">适用于软件著作权登记申请</p>
    </div>

    <div class="page-break"></div>

    <!-- 目录页 -->
    <div class="page">
        <h2>目录</h2>
        <div class="toc">
            <a href="#section1" class="toc-item toc-h2">1. 软件概述</a>
            <a href="#section1-1" class="toc-item toc-h3">1.1 软件背景</a>
            <a href="#section1-2" class="toc-item toc-h3">1.2 设计目标</a>
            <a href="#section1-3" class="toc-item toc-h3">1.3 主要功能</a>
            <a href="#section1-4" class="toc-item toc-h3">1.4 技术特点</a>
            
            <a href="#section2" class="toc-item toc-h2">2. 软件架构设计</a>
            <a href="#section2-1" class="toc-item toc-h3">2.1 总体架构</a>
            <a href="#section2-2" class="toc-item toc-h3">2.2 模块组成</a>
            <a href="#section2-3" class="toc-item toc-h3">2.3 数据流程</a>
            <a href="#section2-4" class="toc-item toc-h3">2.4 关键技术</a>
            
            <a href="#section3" class="toc-item toc-h2">3. 详细功能规格</a>
            <a href="#section3-1" class="toc-item toc-h3">3.1 小说生成功能</a>
            <a href="#section3-2" class="toc-item toc-h3">3.2 AI模型调用</a>
            <a href="#section3-3" class="toc-item toc-h3">3.3 批量处理</a>
            <a href="#section3-4" class="toc-item toc-h3">3.4 续写功能</a>
            <a href="#section3-5" class="toc-item toc-h3">3.5 自动保存</a>
            
            <a href="#section4" class="toc-item toc-h2">4. 系统设计详解</a>
            <a href="#section4-1" class="toc-item toc-h3">4.1 用户界面设计</a>
            <a href="#section4-2" class="toc-item toc-h3">4.2 核心生成器模块</a>
            <a href="#section4-3" class="toc-item toc-h3">4.3 模板系统</a>
            <a href="#section4-4" class="toc-item toc-h3">4.4 工具函数库</a>
            
            <a href="#section5" class="toc-item toc-h2">5. 开发环境与技术栈</a>
            <a href="#section5-1" class="toc-item toc-h3">5.1 开发环境</a>
            <a href="#section5-2" class="toc-item toc-h3">5.2 编程语言</a>
            <a href="#section5-3" class="toc-item toc-h3">5.3 依赖库</a>
            <a href="#section5-4" class="toc-item toc-h3">5.4 开发工具</a>
            
            <a href="#section6" class="toc-item toc-h2">6. 数据结构与算法</a>
            <a href="#section6-1" class="toc-item toc-h3">6.1 数据结构</a>
            <a href="#section6-2" class="toc-item toc-h3">6.2 核心算法</a>
            <a href="#section6-3" class="toc-item toc-h3">6.3 优化策略</a>
            
            <a href="#section7" class="toc-item toc-h2">7. 界面流程图</a>
            <a href="#section7-1" class="toc-item toc-h3">7.1 主界面流程</a>
            <a href="#section7-2" class="toc-item toc-h3">7.2 设置界面流程</a>
            <a href="#section7-3" class="toc-item toc-h3">7.3 生成过程流程</a>
            
            <a href="#section8" class="toc-item toc-h2">8. 核心代码分析</a>
            <a href="#section8-1" class="toc-item toc-h3">8.1 初始化逻辑</a>
            <a href="#section8-2" class="toc-item toc-h3">8.2 API调用实现</a>
            <a href="#section8-3" class="toc-item toc-h3">8.3 生成逻辑</a>
            <a href="#section8-4" class="toc-item toc-h3">8.4 多线程处理</a>
            <a href="#section8-5" class="toc-item toc-h3">8.5 异常处理机制</a>
            
            <a href="#section9" class="toc-item toc-h2">9. 测试过程与结果</a>
            <a href="#section9-1" class="toc-item toc-h3">9.1 测试环境</a>
            <a href="#section9-2" class="toc-item toc-h3">9.2 功能测试</a>
            <a href="#section9-3" class="toc-item toc-h3">9.3 性能测试</a>
            <a href="#section9-4" class="toc-item toc-h3">9.4 兼容性测试</a>
            <a href="#section9-5" class="toc-item toc-h3">9.5 测试结果分析</a>
            
            <a href="#section10" class="toc-item toc-h2">10. 使用说明</a>
            <a href="#section10-1" class="toc-item toc-h3">10.1 安装指南</a>
            <a href="#section10-2" class="toc-item toc-h3">10.2 基本操作</a>
            <a href="#section10-3" class="toc-item toc-h3">10.3 高级功能</a>
            <a href="#section10-4" class="toc-item toc-h3">10.4 常见问题解答</a>

            <a href="#section11" class="toc-item toc-h2">11. 未来发展规划</a>
            <a href="#section11-1" class="toc-item toc-h3">11.1 功能扩展计划</a>
            <a href="#section11-2" class="toc-item toc-h3">11.2 技术改进方向</a>
            <a href="#section11-3" class="toc-item toc-h3">11.3 市场应用前景</a>            
            <a href="#section12" class="toc-item toc-h2">12. 附录</a>
            <a href="#section12-1" class="toc-item toc-h3">12.1 术语表</a>
            <a href="#section12-2" class="toc-item toc-h3">12.2 配置文件说明</a>
            <a href="#section12-3" class="toc-item toc-h3">12.3 版本历史</a>
        </div>
    </div>

    <div class="page-break"></div>

    <!-- 第1章：软件概述 -->
    <div class="page">
        <h2 id="section1">1. 软件概述</h2>
        
        <h3 id="section1-1">1.1 软件背景</h3>
        <p>AI小说生成器是一款专为创作者、写作爱好者和内容创作者设计的智能写作辅助软件。随着人工智能技术的快速发展，特别是自然语言处理领域的突破，AI辅助创作已成为一个新兴且充满潜力的应用方向。本软件正是基于这一技术背景开发的，旨在帮助用户快速生成高质量的小说内容。</p>
        <p>在传统的写作过程中，作者往往需要花费大量时间构思情节、塑造人物、设计世界观等。而AI小说生成器能够通过调用先进的大语言模型，根据用户的简单指令和偏好，自动生成符合特定类型和风格的小说内容，大大提高了创作效率。</p>
        <p>此外，市场上现有的AI写作工具多数功能单一，针对小说这一特定文体的专业化功能不足，且用户界面体验较差。AI小说生成器正是为了填补这一市场空白而开发，为用户提供专业、高效、易用的小说创作辅助工具。</p>
        
        <h3 id="section1-2">1.2 设计目标</h3>
        <p>AI小说生成器的主要设计目标包括：</p>
        <p>1. <strong>高效生成</strong>：通过调用先进的AI模型，快速生成高质量的小说内容，缩短创作周期。用户只需简单设置参数，即可在短时间内获得长篇小说初稿。</p>
        <p>2. <strong>类型多样化</strong>：支持多种小说类型的生成，包括但不限于奇幻冒险、科幻未来、武侠仙侠、悬疑推理、历史传奇、都市情感、校园青春、恐怖惊悚、浪漫爱情、职场商战、乡村生活、异世穿越、末世求生和军事战争等。每种类型都有专门优化的提示词模板，确保生成内容符合该类型的写作特点和风格要求。</p>
        <p>3. <strong>高度定制化</strong>：允许用户自定义多种参数，如主角设定、世界观构建、情节风格、写作风格等，使生成的内容更符合用户的创作意图。</p>
        <p>4. <strong>便捷操作</strong>：设计直观、简洁的用户界面，降低用户使用门槛，使不同水平的用户都能轻松上手。</p>
        <p>5. <strong>可靠性</strong>：实现稳定的AI服务调用，内置自动重试、断点续传等机制，确保生成过程不因网络波动等原因中断。</p>
        <p>6. <strong>内容质量</strong>：通过优化提示词工程、上下文管理等技术，提高生成内容的质量，减少常见问题如逻辑矛盾、人物塑造不一致等。</p>
        
        <h3 id="section1-3">1.3 主要功能</h3>
        <p>AI小说生成器包含以下核心功能：</p>
        <p><strong>1. 多种小说类型生成</strong></p>
        <p>系统内置97种不同类型的小说生成模板，包括奇幻冒险、科幻未来、武侠仙侠、悬疑推理、历史传奇、都市情感、校园青春、恐怖惊悚、浪漫爱情、职场商战、乡村生活、异世穿越、末世求生和军事战争等。每种类型都有专门优化的提示词模板，确保生成内容符合该类型的写作特点和风格要求。</p>
        
        <p><strong>2. 多AI模型支持</strong></p>
        <p>软件支持调用多种先进的AI大语言模型，包括GPT系列、Claude系列、Gemini系列和Moonshot系列等国内外主流模型。用户可以根据自己的API密钥和偏好选择不同的模型，每种模型都经过了特定的参数优化，以获得最佳的小说生成效果。</p>
        
        <p><strong>3. 自定义参数</strong></p>
        <p>用户可以调整多种参数来控制生成结果，包括：</p>
        <ul>
            <li>温度(Temperature)：控制生成内容的随机性和创造性</li>
            <li>核采样(Top-p)：控制词汇选择的多样性</li>
            <li>最大生成长度：设置单次API调用的最大生成字数</li>
            <li>目标总字数：设置小说的总体目标长度</li>
            <li>自定义提示词：高级用户可以编辑提示词模板，更精确地控制生成方向</li>
        </ul>
        
        <p><strong>4. 批量生成</strong></p>
        <p>支持同时生成多篇不同类型的小说，用户可以设置并行数量（默认支持3篇并行生成）。在批量模式下，用户可以选择随机分配小说类型，或为每篇小说单独指定类型。系统通过多线程和异步处理技术实现高效的并行生成，同时确保每篇小说的生成质量不受影响。</p>
    </div>
    
    <div class="page-break"></div>
    
    <!-- 第1章续 -->
    <div class="page">
        <p><strong>5. 续写功能</strong></p>
        <p>软件提供两种续写模式：</p>
        <ul>
            <li>单篇续写：继续创作已有的单个小说文件</li>
            <li>批量续写：选择文件夹进行批量续写，自动处理文件夹中的所有小说</li>
        </ul>
        <p>续写功能会自动分析已有内容，理解故事背景、人物关系和情节走向，然后生成连贯且一致的后续内容。系统还会智能检测并避免重复生成，确保续写部分与原文风格一致。</p>
        
        <p><strong>6. 自动保存</strong></p>
        <p>系统在生成过程中会定期自动保存内容（默认每60秒），确保即使在程序意外关闭或网络中断的情况下，用户也不会丢失已生成的内容。每次保存都会生成两个文件：一个是小说文本文件(.txt)，另一个是包含小说元数据的JSON文件，记录生成参数、当前状态等信息，便于后续续写。</p>
        
        <p><strong>7. 智能摘要</strong></p>
        <p>当小说内容超过一定长度（默认10000字）时，系统会自动生成内容摘要，帮助用户快速了解已生成内容的主要情节和发展。摘要功能利用AI模型对长文本进行分析和提炼，提取出关键情节点、人物发展和主题变化，为用户提供内容导航和创作参考。</p>
        
        <p><strong>8. 智能重试机制</strong></p>
        <p>在网络波动或API调用失败时，系统会自动进行重试，并实现指数退避策略，避免频繁请求导致的API封锁。同时，系统会保持当前状态，确保重试成功后能够无缝继续生成过程，不会对用户体验和内容质量产生负面影响。</p>
        
        <h3 id="section1-4">1.4 技术特点</h3>
        <p>AI小说生成器具有以下技术特点：</p>
        
        <p><strong>1. 高级提示词工程</strong></p>
        <p>软件采用了精心设计的多层级提示词模板系统，包括基础模板、类型特定模板和动态生成模板三个层次。通过提示词工程技术，系统能够引导AI模型生成符合特定小说类型的内容，并在长篇创作过程中保持一致性。提示词模板经过多轮优化和测试，能够最大限度发挥AI模型的创作潜力。</p>
        
        <p><strong>2. 异步并发处理</strong></p>
        <p>系统基于Python的asyncio库实现高效的异步并发处理，支持多小说同时生成和多API请求并行处理。通过信号量控制并发量，避免API请求过载，同时实现资源的高效利用。这一技术特点使得批量生成功能能够在保证质量的同时显著提高效率。</p>
        
        <p><strong>3. 上下文管理</strong></p>
        <p>在长篇小说生成过程中，系统采用智能上下文窗口管理技术，有效处理AI模型的上下文长度限制问题。通过动态调整提示词和历史内容的比例，确保AI模型能够"记住"前文内容，生成连贯一致的故事。同时，系统会定期生成内容摘要，作为上下文压缩的辅助手段，进一步提高长篇创作的质量。</p>
        
        <p><strong>4. 现代GUI设计</strong></p>
        <p>软件采用Tkinter构建现代化图形用户界面，通过自定义样式和布局优化，提供直观、美观的用户体验。界面设计遵循人机交互原则，逻辑清晰，操作简便，适合不同技术水平的用户使用。同时，界面支持高DPI显示，在不同分辨率的显示器上都能保持良好的显示效果。</p>
        
        <p><strong>5. 强大的错误处理</strong></p>
        <p>系统实现了全面的错误处理机制，包括网络错误、API调用错误、内容生成错误等多种情况的处理。通过异常捕获、日志记录、状态恢复等技术，确保在各种异常情况下系统都能保持稳定运行，并尽可能恢复正常工作状态，提高软件的可靠性和用户体验。</p>
    </div>

    <div class="page-break"></div>

    <!-- 第2章：软件架构设计 -->
    <div class="page">
        <h2 id="section2">2. 软件架构设计</h2>
        
        <h3 id="section2-1">2.1 总体架构</h3>
        <p>AI小说生成器采用经典的模块化软件架构，遵循高内聚低耦合的设计原则，将系统划分为多个独立但相互协作的功能模块。整体架构如下：</p>
        
        <div class="svg-container">
            <svg width="600" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 背景 -->
                <rect width="600" height="500" fill="#f9f9f9" rx="10" ry="10"/>
                
                <!-- 模块框 -->
                <rect x="150" y="30" width="300" height="60" rx="5" ry="5" fill="#3498db" stroke="#2980b9" stroke-width="2"/>
                <rect x="150" y="130" width="300" height="60" rx="5" ry="5" fill="#2ecc71" stroke="#27ae60" stroke-width="2"/>
                <rect x="150" y="230" width="300" height="60" rx="5" ry="5" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>
                <rect x="150" y="330" width="300" height="60" rx="5" ry="5" fill="#f39c12" stroke="#d35400" stroke-width="2"/>
                <rect x="150" y="430" width="300" height="60" rx="5" ry="5" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>
                
                <!-- 连接线 -->
                <line x1="300" y1="90" x2="300" y2="130" stroke="#333" stroke-width="2" stroke-dasharray="5,5"/>
                <line x1="300" y1="190" x2="300" y2="230" stroke="#333" stroke-width="2" stroke-dasharray="5,5"/>
                <line x1="300" y1="290" x2="300" y2="330" stroke="#333" stroke-width="2" stroke-dasharray="5,5"/>
                <line x1="300" y1="390" x2="300" y2="430" stroke="#333" stroke-width="2" stroke-dasharray="5,5"/>
                
                <!-- 箭头 -->
                <polygon points="300,130 295,120 305,120" fill="#333"/>
                <polygon points="300,230 295,220 305,220" fill="#333"/>
                <polygon points="300,330 295,320 305,320" fill="#333"/>
                <polygon points="300,430 295,420 305,420" fill="#333"/>
                
                <!-- 文本 -->
                <text x="300" y="65" font-family="Arial" font-size="16" fill="white" text-anchor="middle">main.py</text>
                <text x="300" y="80" font-family="Arial" font-size="12" fill="white" text-anchor="middle">程序入口点，环境初始化，UI启动</text>
                
                <text x="300" y="165" font-family="Arial" font-size="16" fill="white" text-anchor="middle">UI层 (ui/)</text>
                <text x="300" y="180" font-family="Arial" font-size="12" fill="white" text-anchor="middle">用户界面，参数设置，结果显示</text>
                
                <text x="300" y="265" font-family="Arial" font-size="16" fill="white" text-anchor="middle">核心层 (core/)</text>
                <text x="300" y="280" font-family="Arial" font-size="12" fill="white" text-anchor="middle">小说生成逻辑，AI接口调用</text>
                
                <text x="300" y="365" font-family="Arial" font-size="16" fill="white" text-anchor="middle">数据层 (utils/)</text>
                <text x="300" y="380" font-family="Arial" font-size="12" fill="white" text-anchor="middle">配置管理，文件操作，日志记录</text>
                
                <text x="300" y="465" font-family="Arial" font-size="16" fill="white" text-anchor="middle">模板层 (templates/)</text>
                <text x="300" y="480" font-family="Arial" font-size="12" fill="white" text-anchor="middle">提示词模板，类型定义</text>
            </svg>
        </div>
        
        <p>系统采用三层架构设计：</p>
        <p><strong>1. 表示层（Presentation Layer）</strong></p>
        <p>主要由UI模块组成，负责与用户的交互，包括主应用界面（app.py）和各种对话框（dialogs.py）。表示层将用户输入转发给业务逻辑层，并将业务逻辑层的处理结果展示给用户。</p>
        
        <p><strong>2. 业务逻辑层（Business Logic Layer）</strong></p>
        <p>由核心模块组成，实现软件的主要功能，包括小说生成逻辑（generator.py）和模型管理（model_manager.py）。业务逻辑层接收表示层的请求，进行业务处理，并返回处理结果。</p>
        
        <p><strong>3. 数据层（Data Layer）</strong></p>
        <p>负责数据的存储和检索，包括配置管理（config.py）、文件操作等。数据层为业务逻辑层提供数据支持和存储服务。</p>
        
        <p>此外，系统还包含两个横跨多层的通用模块：</p>
        <p><strong>工具库（Utils）</strong>：提供各种通用功能，如日志记录、配置管理、文件操作等。</p>
        <p><strong>模板库（Templates）</strong>：提供小说生成所需的各类提示词模板和类型定义。</p>
        
        <p>整体架构的优势在于：</p>
        <ul>
            <li>高度模块化：各功能模块职责明确，便于开发、测试和维护</li>
            <li>低耦合性：模块间通过清晰的接口通信，减少相互依赖</li>
            <li>可扩展性：可以方便地添加新功能或替换现有模块</li>
            <li>可维护性：便于定位和修复问题，以及进行功能升级</li>
        </ul>
    </div>

    <div class="page-break"></div>
    
    <!-- 第2章续 -->
    <div class="page">
        <h3 id="section2-2">2.2 模块组成</h3>
        <p>AI小说生成器由以下主要模块组成：</p>
        
        <p><strong>1. 主程序模块（main.py）</strong></p>
        <p>作为程序入口点，负责初始化环境、配置日志、加载依赖和启动UI。主程序模块还负责处理全局异常、设置应用ID和资源路径。在打包和非打包环境中，主程序模块会根据不同情况调整运行参数，确保程序在各种环境下都能正常启动。</p>
        
        <p><strong>2. UI模块（ui/）</strong></p>
        <p>包含以下部分：</p>
        <ul>
            <li><strong>app.py</strong>：主应用界面，实现了软件的主窗口及其功能，包括参数设置面板、生成控制面板、输出显示区域等</li>
            <li><strong>dialogs.py</strong>：实现各种对话框，如设置对话框、关于对话框、模型选择对话框等</li>
            <li><strong>assets/</strong>：存储UI所需的图像、图标和样式文件</li>
        </ul>
        <p>UI模块采用Tkinter构建，遵循MVC（模型-视图-控制器）设计模式，将界面展示与业务逻辑分离。界面元素布局采用网格布局（Grid）与框架布局（Frame）相结合的方式，实现灵活的界面结构。</p>
        
        <p><strong>3. 核心模块（core/）</strong></p>
        <p>包含以下部分：</p>
        <ul>
            <li><strong>generator.py</strong>：小说生成器的核心实现，包含文本生成、AI模型调用、批量处理、续写逻辑等功能</li>
            <li><strong>model_manager.py</strong>：管理不同的AI模型，包括模型参数设置、API端点配置等</li>
            <li><strong>import.py</strong>：处理数据导入功能，支持从其他格式导入现有小说内容</li>
        </ul>
        <p>核心模块采用面向对象设计，NovelGenerator类封装了小说生成的核心逻辑，通过丰富的方法提供完整的小说生成功能。异步编程模式（asyncio）的使用使得系统能够高效处理并发请求和批量生成任务。</p>
        
        <p><strong>4. 工具模块（utils/）</strong></p>
        <p>包含以下部分：</p>
        <ul>
            <li><strong>config.py</strong>：配置管理，负责加载、保存和更新程序配置</li>
            <li><strong>common.py</strong>：通用工具函数，如路径处理、时间戳生成、文本处理等</li>
            <li><strong>logging.py</strong>：日志功能，提供统一的日志记录机制</li>
        </ul>
        <p>工具模块采用函数式编程风格，提供清晰的接口供其他模块调用。配置管理采用JSON格式存储，便于人工查看和编辑。日志系统支持同时输出到控制台和文件，便于问题诊断和追踪。</p>
        
        <p><strong>5. 模板模块（templates/）</strong></p>
        <p>包含以下部分：</p>
        <ul>
            <li><strong>prompts.py</strong>：定义各种小说类型的提示词模板，包括基础模板、类型特定模板、结局模板等</li>
        </ul>
        <p>模板模块采用声明式设计，将提示词内容与处理逻辑分离。每种小说类型都有独立的模板定义，包含该类型特有的元素和写作风格指导。模板支持变量插值，可根据用户设置动态生成最终的提示词。</p>
        
        <p><strong>6. 构建模块（build.py, build.bat）</strong></p>
        <p>负责软件的打包和分发，将Python源码转换为可执行文件。构建模块使用PyInstaller工具，支持多种打包模式（单文件、目录），并处理资源文件的包含和依赖库的管理。</p>
    </div>
    
    <div class="page-break"></div>

    <!-- 第3章：详细功能规格 -->
    <div class="page">
        <h2 id="section3">3. 详细功能规格</h2>
        
        <h3 id="section3-1">3.1 小说生成功能</h3>
        <p>AI小说生成器包含以下核心功能：</p>
        <p><strong>1. 多种小说类型生成</strong></p>
        <p>系统内置14种不同类型的小说生成模板，包括奇幻冒险、科幻未来、武侠仙侠、悬疑推理、历史传奇、都市情感、校园青春、恐怖惊悚、浪漫爱情、职场商战、乡村生活、异世穿越、末世求生和军事战争等。每种类型都有专门优化的提示词模板，确保生成内容符合该类型的写作特点和风格要求。</p>
        
        <p><strong>2. 多AI模型支持</strong></p>
        <p>软件支持调用多种先进的AI大语言模型，包括GPT系列、Claude系列、Gemini系列和Moonshot系列等国内外主流模型。用户可以根据自己的API密钥和偏好选择不同的模型，每种模型都经过了特定的参数优化，以获得最佳的小说生成效果。</p>
        
        <p><strong>3. 自定义参数</strong></p>
        <p>用户可以调整多种参数来控制生成结果，包括：</p>
        <ul>
            <li>温度(Temperature)：控制生成内容的随机性和创造性</li>
            <li>核采样(Top-p)：控制词汇选择的多样性</li>
            <li>最大生成长度：设置单次API调用的最大生成字数</li>
            <li>目标总字数：设置小说的总体目标长度</li>
            <li>自定义提示词：高级用户可以编辑提示词模板，更精确地控制生成方向</li>
        </ul>
        
        <p><strong>4. 批量生成</strong></p>
        <p>支持同时生成多篇不同类型的小说，用户可以设置并行数量（默认支持3篇并行生成）。在批量模式下，用户可以选择随机分配小说类型，或为每篇小说单独指定类型。系统通过多线程和异步处理技术实现高效的并行生成，同时确保每篇小说的生成质量不受影响。</p>
    </div>
    
    <div class="page-break"></div>

    <!-- 第4章：系统设计详解 -->
    <div class="page">
        <h2 id="section4">4. 系统设计详解</h2>
        
        <h3 id="section4-1">4.1 用户界面设计</h3>
        <p>AI小说生成器的用户界面设计遵循人机交互原则，逻辑清晰，操作简便，适合不同技术水平的用户使用。界面设计采用网格布局（Grid）与框架布局（Frame）相结合的方式，实现灵活的界面结构。</p>
        
        <h3 id="section4-2">4.2 核心生成器模块</h3>
        <p>核心生成器模块是AI小说生成器的核心部分，包含小说生成逻辑、AI接口调用、批量处理、续写逻辑等功能。核心模块采用面向对象设计，NovelGenerator类封装了小说生成的核心逻辑，通过丰富的方法提供完整的小说生成功能。</p>
        
        <h3 id="section4-3">4.3 模板系统</h3>
        <p>AI小说生成器采用了精心设计的多层级提示词模板系统，包括基础模板、类型特定模板和动态生成模板三个层次。通过提示词工程技术，系统能够引导AI模型生成符合特定小说类型的内容，并在长篇创作过程中保持一致性。提示词模板经过多轮优化和测试，能够最大限度发挥AI模型的创作潜力。</p>
        
        <h3 id="section4-4">4.4 工具函数库</h3>
        <p>AI小说生成器包含以下通用功能：</p>
        <ul>
            <li><strong>日志记录</strong>：提供统一的日志记录机制，便于问题诊断和追踪</li>
            <li><strong>配置管理</strong>：负责加载、保存和更新程序配置</li>
            <li><strong>文件操作</strong>：处理各种文件操作，如路径处理、时间戳生成、文本处理等</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第5章：开发环境与技术栈 -->
    <div class="page">
        <h2 id="section5">5. 开发环境与技术栈</h2>
        
        <h3 id="section5-1">5.1 开发环境</h3>
        <p>AI小说生成器的开发环境包括：</p>
        <ul>
            <li>操作系统：Windows、Linux、macOS等</li>
            <li>开发工具：PyCharm、VSCode等</li>
            <li>依赖库：asyncio、Tkinter、PyInstaller等</li>
        </ul>
        
        <h3 id="section5-2">5.2 编程语言</h3>
        <p>AI小说生成器主要使用Python编程语言进行开发，Python具有易学易用、功能强大、生态丰富的特点，适合快速开发和维护。</p>
        
        <h3 id="section5-3">5.3 依赖库</h3>
        <p>AI小说生成器依赖以下第三方库：</p>
        <ul>
            <li><strong>asyncio</strong>：用于实现异步并发处理</li>
            <li><strong>Tkinter</strong>：用于构建现代化图形用户界面</li>
            <li><strong>PyInstaller</strong>：用于将Python源码转换为可执行文件</li>
        </ul>
        
        <h3 id="section5-4">5.4 开发工具</h3>
        <p>AI小说生成器的开发工具包括：</p>
        <ul>
            <li><strong>PyCharm</strong>：用于代码编辑和调试</li>
            <li><strong>VSCode</strong>：用于代码编辑和调试</li>
            <li><strong>Git</strong>：用于版本控制和协作开发</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第6章：数据结构与算法 -->
    <div class="page">
        <h2 id="section6">6. 数据结构与算法</h2>
        
        <h3 id="section6-1">6.1 数据结构</h3>
        <p>AI小说生成器的数据结构主要包括：</p>
        <ul>
            <li><strong>提示词模板</strong>：用于存储各种小说类型的提示词模板</li>
            <li><strong>小说数据</strong>：用于存储小说生成过程中产生的各种数据</li>
            <li><strong>配置信息</strong>：用于存储程序配置信息</li>
        </ul>
        
        <h3 id="section6-2">6.2 核心算法</h3>
        <p>AI小说生成器的核心算法包括：</p>
        <ul>
            <li><strong>提示词工程</strong>：用于生成符合特定小说类型的内容</li>
            <li><strong>上下文管理</strong>：用于处理AI模型的上下文长度限制问题</li>
            <li><strong>异步并发处理</strong>：用于实现多小说同时生成和多API请求并行处理</li>
        </ul>
        
        <h3 id="section6-3">6.3 优化策略</h3>
        <p>AI小说生成器的优化策略包括：</p>
        <ul>
            <li><strong>提示词模板优化</strong>：通过多轮优化和测试，最大限度发挥AI模型的创作潜力</li>
            <li><strong>上下文管理优化</strong>：通过动态调整提示词和历史内容的比例，进一步提高长篇创作的质量</li>
            <li><strong>异步并发处理优化</strong>：通过信号量控制并发量，避免API请求过载，同时实现资源的高效利用</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第7章：界面流程图 -->
    <div class="page">
        <h2 id="section7">7. 界面流程图</h2>
        
        <h3 id="section7-1">7.1 主界面流程</h3>
        <p>AI小说生成器的主界面流程包括：</p>
        <ul>
            <li>启动程序</li>
            <li>加载配置</li>
            <li>初始化界面</li>
            <li>处理用户输入</li>
            <li>生成小说内容</li>
            <li>显示结果</li>
        </ul>
        
        <h3 id="section7-2">7.2 设置界面流程</h3>
        <p>AI小说生成器的设置界面流程包括：</p>
        <ul>
            <li>进入设置界面</li>
            <li>选择设置选项</li>
            <li>输入或修改设置参数</li>
            <li>保存设置</li>
        </ul>
        
        <h3 id="section7-3">7.3 生成过程流程</h3>
        <p>AI小说生成器的生成过程流程包括：</p>
        <ul>
            <li>选择小说类型</li>
            <li>设置生成参数</li>
            <li>调用AI模型</li>
            <li>生成小说内容</li>
            <li>保存生成结果</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第8章：核心代码分析 -->
    <div class="page">
        <h2 id="section8">8. 核心代码分析</h2>
        
        <h3 id="section8-1">8.1 初始化逻辑</h3>
        <p>AI小说生成器的核心是NovelGenerator类，负责处理所有的小说生成逻辑。以下是NovelGenerator类的初始化代码分析：</p>
        
        <div class="code">
class NovelGenerator:
    def __init__(self, api_key: str, model: str = "gpt-4.5-preview",
                 max_workers: int = 3, language: str = "中文",
                 novel_type: str = "奇幻冒险",
                 custom_prompt: Optional[str] = None,
                 target_length: int = 20000,
                 temperature: float = 0.8,
                 top_p: float = 0.9,
                 max_tokens: int = 4000,
                 context_length: int = 100000,
                 status_callback=None,
                 num_novels: int = 1,
                 random_types: bool = False,
                 create_ending: bool = False,
                 continue_from_file: Optional[str] = None,
                 continue_from_dir: Optional[str] = None,
                 progress_callback=None,
                 autosave_interval: int = 60,
                 novel_types_for_batch: list = None,
                 retry_callback=None,
                 auto_summary_interval: int = 10000):
        
        # 初始化参数属性
        self.api_key = api_key
        self.model = model
        self.max_workers = max_workers
        self.language = language
        self.novel_type = novel_type
        self.custom_prompt = custom_prompt
        self.target_length = target_length
        self.temperature = temperature
        self.top_p = top_p
        self.max_tokens = max_tokens
        self.context_length = context_length
        self.status_callback = status_callback
        self.num_novels = num_novels
        self.random_types = random_types
        self.create_ending = create_ending
        self.continue_from_file = continue_from_file
        self.continue_from_dir = continue_from_dir
        self.progress_callback = progress_callback
        self.autosave_interval = autosave_interval
        self.novel_types_for_batch = novel_types_for_batch
        self.retry_callback = retry_callback
        self.auto_summary_interval = auto_summary_interval
        
        # API相关初始化
        self.base_url = "https://aiapi.space/v1/chat/completions"
        self.session = None
        self.existing_content = {}
        
        # 小说生成状态控制
        self.running = False
        self.paused = False
        self.stop_event = threading.Event()
        self.pause_event = threading.Event()
        self.pause_event.set()  # 初始状态为未暂停
        
        # 当前小说状态
        self.current_novel_setup = None
        self.current_novel_text = ""
        self.last_save_time = 0
        self.last_summary_word_count = 0
        self.novel_summaries = []
        
        # 输出目录
        self.output_dir = get_output_dir()
        
        # 续写文件列表
        self.continuation_files = []
        
        # 如果是续写模式，加载现有小说
        if self.continue_from_file:
            self._load_existing_novel()
        # 如果是多篇续写模式，加载文件夹中的所有小说
        elif self.continue_from_dir:
            self._load_novels_from_directory()
        </div>

        <p>代码分析：</p>
        <ul>
            <li><strong>参数设计</strong>：NovelGenerator类接受多个参数，提供了高度灵活性和可定制性。默认值设置合理，使初学者也能快速上手。</li>
            <li><strong>状态管理</strong>：初始化了多个状态变量，用于跟踪生成过程、控制暂停/停止、管理保存间隔等。</li>
            <li><strong>线程控制</strong>：使用threading.Event对象实现线程间的同步，支持暂停/恢复/停止等操作。</li>
            <li><strong>续写模式支持</strong>：通过条件判断初始化时决定是否加载现有小说内容，支持单文件续写和批量续写两种模式。</li>
            <li><strong>类型注解</strong>：使用Python的类型提示功能，提高代码可读性和IDE支持。</li>
        </ul>
        
        <h3 id="section8-2">8.2 API调用实现</h3>
        <p>AI小说生成器通过异步API调用与AI模型通信，下面是核心API调用实现代码：</p>
        
        <div class="code">
async def _generate_text(self, prompt, model=None, temperature=None, top_p=None, max_tokens=None, retries=3, retry_delay=1):
    """调用API生成文本"""
    model = model or self.model
    temperature = temperature if temperature is not None else self.temperature
    top_p = top_p if top_p is not None else self.top_p
    max_tokens = max_tokens or self.max_tokens
    
    if self.stop_event.is_set():
        return None
        
    # 创建会话（如果不存在）
    if not self.session:
        self.session = aiohttp.ClientSession()
    
    # 准备请求数据
    payload = {
        "model": model,
        "messages": [{"role": "user", "content": prompt}],
        "temperature": temperature,
        "top_p": top_p,
        "max_tokens": max_tokens
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {self.api_key}"
    }
    
    # 执行请求，支持重试
    for attempt in range(retries):
        try:
            # 检查是否需要暂停
            await self._check_pause()
            
            # 如果已停止，直接返回
            if self.stop_event.is_set():
                return None
                
            # 发送API请求
            async with self.session.post(
                self.base_url,
                json=payload,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=120)  # 2分钟超时
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    # 提取生成的文本
                    generated_text = result["choices"][0]["message"]["content"]
                    return generated_text
                else:
                    error_text = await response.text()
                    self.update_status(f"API调用失败（状态码：{response.status}）：{error_text}")
                    
                    # 通知重试
                    if self.retry_callback:
                        self.retry_callback(attempt + 1, retries, retry_delay * (2 ** attempt))
                    
                    # 如果不是最后一次尝试，则等待后重试
                    if attempt < retries - 1:
                        await asyncio.sleep(retry_delay * (2 ** attempt))  # 指数退避
                    else:
                        raise Exception(f"API调用失败：{error_text}")
        except Exception as e:
            self.update_status(f"API调用异常：{str(e)}")
            
            # 通知重试
            if self.retry_callback:
                self.retry_callback(attempt + 1, retries, retry_delay * (2 ** attempt))
            
            # 如果不是最后一次尝试，则等待后重试
            if attempt < retries - 1:
                await asyncio.sleep(retry_delay * (2 ** attempt))  # 指数退避
            else:
                raise
        </div>

        <p>代码分析：</p>
        <ul>
            <li><strong>异步实现</strong>：使用Python的asyncio和aiohttp库实现异步API调用，提高并发性能。</li>
            <li><strong>智能重试机制</strong>：实现了指数退避（Exponential Backoff）策略，避免频繁请求导致API封锁。</li>
            <li><strong>状态检查</strong>：在每次API调用前检查暂停和停止状态，实现可控的生成过程。</li>
            <li><strong>超时控制</strong>：设置120秒的请求超时，避免因网络问题导致无限等待。</li>
            <li><strong>错误处理</strong>：捕获并处理各种可能的异常情况，确保程序稳定性。</li>
            <li><strong>回调通知</strong>：通过callback函数通知UI层重试状态，提供良好的用户体验。</li>
        </ul>
        
        <h3 id="section8-3">8.3 生成逻辑</h3>
        <p>小说生成的核心逻辑包含在NovelGenerator类的异步生成方法中：</p>
        
        <div class="code">
async def _generate_content(self, novel_setup, current_text="", is_continuation=False):
    """生成小说内容的异步方法，支持续写"""
    try:
        # 如果是续写模式且有现有内容，则从已有内容继续
        if is_continuation and current_text:
            text = current_text
            self.update_status("开始续写现有内容...")
        else:
            text = ""
            self.update_status("开始生成小说内容...")
            
        # 计算目标长度
        target_length = novel_setup.get("target_length", self.target_length)
        
        # 生成内容直到达到目标长度
        while len(text) < target_length:
            # 检查是否需要暂停或停止
            await self._check_pause()
            if self.stop_event.is_set():
                return text
                
            # 获取当前进度
            progress = len(text) / target_length * 100
            if self.progress_callback:
                self.progress_callback(progress)
                
            # 检查是否需要生成摘要（用于上下文压缩）
            if len(text) - self.last_summary_word_count > self.auto_summary_interval:
                await self._generate_summary(text, novel_setup)
                
            # 生成提示词
            prompt = self.get_prompt(novel_setup, text, self.novel_summaries)
            
            # 调用API生成文本
            generated_text = await self._generate_text(prompt)
            if not generated_text:
                break
                
            # 清理和格式化生成的内容
            clean_text = self._clean_content(generated_text)
            
            # 避免重复生成
            if self._is_text_too_similar(clean_text, text[-1000:]):
                self.update_status("检测到重复内容，重新生成...")
                continue
                
            # 添加到现有文本中
            text += clean_text
            
            # 更新状态
            self.update_status(f"已生成 {len(text)} 字（{progress:.1f}%）")
            
            # 自动保存
            if time.time() - self.last_save_time > self.autosave_interval:
                await self._save_current_novel(novel_setup, text)
                
        # 如果需要创建结局
        if self.create_ending and len(text) >= target_length * 0.9:
            ending_text = await self._generate_ending(novel_setup, text)
            text += "\n\n" + ending_text
            
        # 最终保存
        await self._save_current_novel(novel_setup, text, is_final=True)
        
        self.update_status("小说生成完成！")
        return text
    except Exception as e:
        error_msg = f"生成过程出错: {str(e)}\n{traceback.format_exc()}"
        self.update_status(error_msg)
        # 发生错误时尝试保存已生成内容
        if text:
            await self._save_current_novel(novel_setup, text, is_error=True)
        return text
        </div>

        <p>代码分析：</p>
        <ul>
            <li><strong>循环生成</strong>：通过循环不断生成内容，直到达到目标字数。</li>
            <li><strong>上下文管理</strong>：使用自动摘要功能压缩长文本，解决AI模型上下文长度限制问题。</li>
            <li><strong>重复检测</strong>：通过相似度算法检测生成内容是否与最近内容过于相似，避免重复生成。</li>
            <li><strong>自动保存</strong>：设置定时保存机制，确保即使程序崩溃也不会丢失大量内容。</li>
            <li><strong>结局生成</strong>：当内容达到目标长度90%时可选择生成专门的结局，使故事完整。</li>
            <li><strong>错误处理</strong>：完善的错误处理机制，即使出错也会尝试保存已生成的内容。</li>
            <li><strong>进度反馈</strong>：通过回调函数向用户界面提供实时进度更新。</li>
        </ul>
        
        <h3 id="section8-4">8.4 多线程处理</h3>
        <p>AI小说生成器通过异步编程和线程管理实现并行处理，以下是核心的批量生成实现代码：</p>
        
        <div class="code">
async def generate_novels(self):
    """生成一个或多个小说的入口方法"""
    if self.running:
        self.update_status("已有生成任务正在运行")
        return
    
    try:
        self.running = True
        self.stop_event.clear()
        self.pause_event.set()  # 确保初始状态为非暂停
        
        # 如果是批量续写模式
        if self.continue_from_dir and self.continuation_files:
            results = await self._continue_novels_from_directory()
            return results
        
        # 如果是单个续写模式
        if self.continue_from_file:
            result = await self._continue_single_novel()
            return [result] if result else []
        
        # 正常生成模式（单个或批量）
        self.update_status(f"准备生成 {self.num_novels} 篇小说")
        
        # 创建异步任务
        tasks = []
        for i in range(self.num_novels):
            # 为每个小说创建设定
            novel_setup = self._create_novel_setup(i)
            # 创建生成任务
            task = self._novel_worker(novel_setup, i)
            tasks.append(task)
            
        # 使用异步任务池限制并发数量
        semaphore = asyncio.Semaphore(self.max_workers)
        
        async def worker_with_semaphore(task, index):
            async with semaphore:
                self.update_status(f"开始生成第 {index+1} 篇小说")
                return await task
        
        # 包装任务使用信号量控制并发
        limited_tasks = [worker_with_semaphore(task, i) for i, task in enumerate(tasks)]
        
        # 并行执行所有任务
        results = await asyncio.gather(*limited_tasks, return_exceptions=True)
        
        # 处理结果
        success_count = sum(1 for r in results if not isinstance(r, Exception) and r)
        self.update_status(f"完成! 成功生成 {success_count}/{self.num_novels} 篇小说")
        
        # 返回生成的文件路径列表
        return [r for r in results if not isinstance(r, Exception) and r]
    except Exception as e:
        error_msg = f"生成过程出错: {str(e)}\n{traceback.format_exc()}"
        self.update_status(error_msg)
        return []
    finally:
        self.running = False

async def _novel_worker(self, novel_setup, index):
    """单个小说的生成工作者"""
    try:
        novel_type = novel_setup.get("novel_type", self.novel_type)
        self.update_status(f"[小说 {index+1}] 开始生成 {novel_type} 类型的小说")
        
        # 生成小说内容
        text = await self._generate_content(novel_setup)
        
        # 如果生成被停止，返回None
        if self.stop_event.is_set():
            return None
            
        # 保存最终文件
        output_path = await self._save_final_novel(novel_setup, text, index)
        
        self.update_status(f"[小说 {index+1}] 生成完成，保存到: {output_path}")
        return output_path
    except Exception as e:
        error_msg = f"[小说 {index+1}] 生成过程出错: {str(e)}\n{traceback.format_exc()}"
        self.update_status(error_msg)
        return None
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>异步并发</strong>：使用asyncio.gather实现并行任务处理，同时生成多篇小说。</li>
            <li><strong>资源控制</strong>：通过asyncio.Semaphore信号量控制同时运行的工作任务数量，避免资源过载。</li>
            <li><strong>模式适配</strong>：根据不同的运行模式（批量生成、单文件续写、目录续写）选择相应的处理逻辑。</li>
            <li><strong>状态跟踪</strong>：为每个生成任务提供独立的状态更新，便于用户监控多任务进度。</li>
            <li><strong>异常隔离</strong>：每个任务的异常不会影响其他任务的执行，提高系统鲁棒性。</li>
            <li><strong>结果汇总</strong>：统计成功和失败的任务数量，提供整体执行情况报告。</li>
        </ul>
        
        <h3 id="section8-5">8.5 异常处理机制</h3>
        <p>AI小说生成器实现了全面的异常处理机制，以下是代表性的异常处理代码：</p>
        
        <div class="code">
async def _save_current_novel(self, novel_setup, text, is_final=False, is_error=False):
    """保存当前小说内容和元数据"""
    try:
        # 如果没有文本，则不保存
        if not text:
            return
        
        # 确保输出目录存在
        os.makedirs(self.output_dir, exist_ok=True)
        
        # 获取小说类型和主角
        novel_type = novel_setup.get("novel_type", self.novel_type)
        protagonist = novel_setup.get("protagonist", {}).get("name", "主角")
        
        # 创建基本文件名
        if is_final:
            base_filename = f"{novel_type}_{protagonist}_完成"
        elif is_error:
            base_filename = f"{novel_type}_{protagonist}_错误恢复"
        else:
            base_filename = f"{novel_type}_{protagonist}_自动保存"
        
        # 构建完整文件路径
        txt_path = os.path.join(self.output_dir, f"{base_filename}.txt")
        meta_path = os.path.join(self.output_dir, f"{base_filename}_meta.json")
        
        # 保存小说文本
        with open(txt_path, 'w', encoding='utf-8') as f:
            f.write(text)
        
        # 保存元数据
        with open(meta_path, 'w', encoding='utf-8') as f:
            # 添加当前长度到元数据
            novel_setup["current_length"] = len(text)
            novel_setup["last_update"] = time.time()
            json.dump(novel_setup, f, ensure_ascii=False, indent=2)
        
        # 更新最后保存时间
        self.last_save_time = time.time()
        
        # 如果不是最终保存，更新状态
        if not is_final and not is_error:
            self.update_status(f"已自动保存，当前字数: {len(text)}")
        elif is_error:
            self.update_status(f"在错误发生后已保存当前内容到: {txt_path}")
        
        return txt_path
    except Exception as e:
        # 如果保存过程中出错
        error_msg = f"保存内容时出错: {str(e)}"
        self.update_status(error_msg)
        
        # 尝试使用更简单的方式保存
        try:
            emergency_path = os.path.join(self.output_dir, f"emergency_save_{get_timestamp()}.txt")
            with open(emergency_path, 'w', encoding='utf-8') as f:
                f.write(text)
            self.update_status(f"已紧急保存内容到: {emergency_path}")
            return emergency_path
        except:
            self.update_status("紧急保存也失败，无法保存内容")
            return None

def pause(self):
    """暂停生成过程"""
    if self.running and not self.paused:
        self.paused = True
        self.pause_event.clear()
        self.update_status("生成过程已暂停")
        return True
    return False

def resume(self):
    """恢复生成过程"""
    if self.running and self.paused:
        self.paused = False
        self.pause_event.set()
        self.update_status("生成过程已恢复")
        return True
    return False

def stop(self):
    """停止生成过程"""
    if self.running:
        self.stop_event.set()
        self.pause_event.set()  # 确保不会卡在暂停状态
        self.update_status("正在停止生成过程...")
        return True
    return False

async def _check_pause(self):
    """检查是否需要暂停，如果是则等待恢复"""
    while not self.pause_event.is_set() and not self.stop_event.is_set():
        await asyncio.sleep(0.1)  # 小间隔检查，避免CPU占用过高
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>多层保护</strong>：实现了主保存和紧急保存两层机制，即使主保存失败，也能通过紧急保存避免数据丢失。</li>
            <li><strong>状态控制</strong>：通过暂停、恢复和停止三个方法实现对生成过程的完全控制。</li>
            <li><strong>异步暂停</strong>：使用_check_pause方法实现异步暂停，保证线程安全。</li>
            <li><strong>错误恢复</strong>：区分正常保存、最终保存和错误后保存，便于用户在出错后找回数据。</li>
            <li><strong>日志记录</strong>：全程记录状态变化和错误信息，便于诊断问题。</li>
            <li><strong>资源释放</strong>：在停止操作中确保释放所有资源，避免资源泄漏。</li>
        </ul>
        
        <p>NovelGenerator类的设计充分考虑了产品级应用的需求，实现了高可靠性、高灵活性和良好的容错能力。通过合理的异步编程和错误处理策略，使得系统在各种复杂场景下都能稳定运行，保障用户体验。</p>
    </div>
    
    <div class="page-break"></div>

    <!-- 第9章：测试过程与结果 -->
    <div class="page">
        <h2 id="section9">9. 测试过程与结果</h2>
        
        <h3 id="section9-1">9.1 测试环境</h3>
        <p>AI小说生成器的测试环境包括：</p>
        <ul>
            <li>操作系统：Windows、Linux、macOS等</li>
            <li>开发工具：PyCharm、VSCode等</li>
            <li>依赖库：asyncio、Tkinter、PyInstaller等</li>
        </ul>
        
        <h3 id="section9-2">9.2 功能测试</h3>
        <p>AI小说生成器的功能测试包括：</p>
        <ul>
            <li>多种小说类型生成</li>
            <li>多AI模型支持</li>
            <li>自定义参数</li>
            <li>批量生成</li>
            <li>续写功能</li>
            <li>自动保存</li>
            <li>智能摘要</li>
            <li>智能重试机制</li>
        </ul>
        
        <h3 id="section9-3">9.3 性能测试</h3>
        <p>AI小说生成器的性能测试包括：</p>
        <ul>
            <li>单篇小说生成时间</li>
            <li>批量生成效率</li>
            <li>系统资源占用</li>
        </ul>
        
        <h3 id="section9-4">9.4 兼容性测试</h3>
        <p>AI小说生成器的兼容性测试包括：</p>
        <ul>
            <li>不同操作系统</li>
            <li>不同分辨率显示器</li>
            <li>不同依赖库版本</li>
        </ul>
        
        <h3 id="section9-5">9.5 测试结果分析</h3>
        <p>AI小说生成器的测试结果分析包括：</p>
        <ul>
            <li>测试结果统计</li>
            <li>性能瓶颈分析</li>
            <li>兼容性问题总结</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第10章：使用说明 -->
    <div class="page">
        <h2 id="section10">10. 使用说明</h2>
        
        <h3 id="section10-1">10.1 安装指南</h3>
        <p>AI小说生成器的安装指南包括：</p>
        <ul>
            <li>下载安装包</li>
            <li>解压安装文件</li>
            <li>运行安装程序</li>
        </ul>
        
        <h3 id="section10-2">10.2 基本操作</h3>
        <p>AI小说生成器的基本操作包括：</p>
        <ul>
            <li>启动软件</li>
            <li>选择小说类型</li>
            <li>设置生成参数</li>
            <li>生成小说内容</li>
        </ul>
        
        <h3 id="section10-3">10.3 高级功能</h3>
        <p>AI小说生成器的高级功能包括：</p>
        <ul>
            <li>批量生成</li>
            <li>续写功能</li>
            <li>自动保存</li>
            <li>智能摘要</li>
            <li>智能重试机制</li>
        </ul>
        
        <h3 id="section10-4">10.4 常见问题解答</h3>
        <p>AI小说生成器的常见问题解答包括：</p>
        <ul>
            <li>如何选择小说类型</li>
            <li>如何设置生成参数</li>
            <li>如何处理生成错误</li>
            <li>如何使用高级功能</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第11章：未来发展规划 -->
    <div class="page">
        <h2 id="section11">11. 未来发展规划</h2>
        
        <h3 id="section11-1">11.1 功能扩展计划</h3>
        <p>AI小说生成器的功能扩展计划包括：</p>
        <ul>
            <li>增加小说类型</li>
            <li>扩展续写功能</li>
            <li>实现自动摘要</li>
            <li>添加批量导入功能</li>
        </ul>
        
        <h3 id="section11-2">11.2 技术改进方向</h3>
        <p>AI小说生成器的改进方向包括：</p>
        <ul>
            <li>优化提示词工程</li>
            <li>改进上下文管理</li>
            <li>提高异步并发处理能力</li>
            <li>增强错误处理机制</li>
        </ul>
        
        <h3 id="section11-3">11.3 市场应用前景</h3>
        <p>AI小说生成器的应用前景包括：</p>
        <ul>
            <li>创作者辅助工具</li>
            <li>写作爱好者工具</li>
            <li>内容创作者工具</li>
            <li>教育辅助工具</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <!-- 第12章：附录 -->
    <div class="page">
        <h2 id="section12">12. 附录</h2>
        
        <h3 id="section12-1">12.1 术语表</h3>
        <p>AI小说生成器涉及以下术语：</p>
        <ul>
            <li><strong>提示词模板</strong>：用于存储各种小说类型的提示词模板</li>
            <li><strong>小说数据</strong>：用于存储小说生成过程中产生的各种数据</li>
            <li><strong>配置信息</strong>：用于存储程序配置信息</li>
        </ul>
        
        <h3 id="section12-2">12.2 配置文件说明</h3>
        <p>AI小说生成器的配置文件包括：</p>
        <ul>
            <li><strong>config.py</strong>：配置管理，负责加载、保存和更新程序配置</li>
            <li><strong>common.py</strong>：通用工具函数，如路径处理、时间戳生成、文本处理等</li>
            <li><strong>logging.py</strong>：日志功能，提供统一的日志记录机制</li>
        </ul>
        
        <h3 id="section12-3">12.3 版本历史</h3>
        <p>AI小说生成器的版本历史包括：</p>
        <ul>
            <li>版本1.0.0：初始版本，实现基本的小说生成功能</li>
            <li>版本2.0.0：增加多AI模型支持，优化提示词工程</li>
            <li>版本3.0.0：实现批量生成和续写功能</li>
            <li>版本4.0.0：优化上下文管理，增强错误处理机制</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section9">9. 用户界面交互分析</h2>
        <h3 id="section9-1">9.1 用户界面架构</h3>
        <p>AI小说生成器采用了基于Tkinter的模块化UI架构，主界面代码示例如下：</p>
        
        <div class="code">
class NovelGeneratorApp:
    """AI小说生成器主应用类"""
    
    def __init__(self, root):
        """初始化应用"""
        self.root = root
        self.root.title("AI小说生成器")
        
        # 创建样式
        self.style = ttk.Style()
        self.apply_theme()
        
        # 创建主框架
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # 创建选项卡控件
        self.notebook = ttk.Notebook(self.main_frame)
        
        # 创建各个页面
        self.setup_generation_tab()   # 小说生成页
        self.setup_templates_tab()    # 模板管理页
        self.setup_settings_tab()     # 设置页
        self.setup_about_tab()        # 关于页
        
        # 放置选项卡控件
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # 创建底部状态栏
        self.setup_status_bar()
        
        # 初始化生成器
        self.init_generator()
        
        # 定时器，用于更新UI状态
        self.setup_timers()
        
        # 加载配置
        self.load_config()
        
        # 绑定关闭事件
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
    def setup_generation_tab(self):
        """设置小说生成页"""
        self.generation_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.generation_frame, text="小说生成")
        
        # 创建两列布局：左侧为输入区，右侧为输出区
        self.generation_paned = ttk.PanedWindow(self.generation_frame, orient=tk.HORIZONTAL)
        self.generation_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 左侧输入区
        self.input_frame = ttk.LabelFrame(self.generation_paned, text="生成设置")
        
        # 添加输入控件
        self.setup_input_controls()
        
        # 右侧输出区
        self.output_frame = ttk.LabelFrame(self.generation_paned, text="生成结果")
        
        # 添加输出控件
        self.setup_output_controls()
        
        # 添加到分隔窗口
        self.generation_paned.add(self.input_frame, weight=40)
        self.generation_paned.add(self.output_frame, weight=60)
        
    def on_generate_click(self):
        """处理生成按钮点击事件"""
        # 禁用生成按钮，避免重复点击
        self.generate_button.config(state=tk.DISABLED)
        
        # 更新状态
        self.update_status("正在准备生成...")
        
        # 从UI收集参数
        params = self.collect_generation_params()
        
        # 开始异步生成过程
        self.start_generation(params)
    
    def update_ui(self):
        """定时更新UI状态"""
        if self.generator:
            # 获取生成器当前状态
            status = self.generator.get_status()
            progress = self.generator.get_progress()
            
            # 更新状态栏
            if status:
                self.status_var.set(status)
            
            # 更新进度条
            if progress is not None:
                self.progress_var.set(progress)
            
            # 更新控制按钮状态
            self.update_control_buttons()
            
            # 如果有新生成的内容，更新显示
            content = self.generator.get_current_content()
            if content and content != self.last_content:
                self.output_text.delete(1.0, tk.END)
                self.output_text.insert(tk.END, content)
                self.last_content = content
        
        # 继续定时调用
        self.root.after(100, self.update_ui)
    
    def on_closing(self):
        """应用关闭时处理"""
        if self.generator and self.generator.is_running():
            # 如果有生成任务在运行，提示用户
            if messagebox.askyesno("关闭确认", 
                                  "有生成任务正在进行，关闭将中断任务。\n确定要关闭吗？"):
                # 停止生成任务
                self.generator.stop()
                # 保存配置
                self.save_config()
                # 关闭应用
                self.root.destroy()
        else:
            # 保存配置
            self.save_config()
            # 关闭应用
            self.root.destroy()
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>模块化设计</strong>：将UI分为不同的选项卡和组件，便于维护和扩展。</li>
            <li><strong>事件驱动</strong>：基于Tkinter的事件机制处理用户交互。</li>
            <li><strong>异步更新</strong>：使用定时器定期更新UI，避免界面冻结。</li>
            <li><strong>状态管理</strong>：维护UI状态和后台生成器状态的同步。</li>
            <li><strong>资源释放</strong>：在应用关闭时确保资源正确释放和配置保存。</li>
        </ul>
        
        <p>以下是用户界面架构的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="500" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">AI小说生成器用户界面架构</text>
                
                <!-- 主应用框架 -->
                <rect x="50" y="60" width="700" height="400" fill="#e6f3ff" rx="5" ry="5" stroke="#666" stroke-width="2"/>
                <text x="400" y="80" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">NovelGeneratorApp</text>
                
                <!-- 选项卡区域 -->
                <rect x="70" y="100" width="660" height="300" fill="#ffffff" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="400" y="120" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">Notebook 控件</text>
                
                <!-- 各个选项卡 -->
                <rect x="90" y="140" width="150" height="240" fill="#ffecb3" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="165" y="160" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">小说生成页</text>
                
                <rect x="250" y="140" width="150" height="240" fill="#e1f5fe" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="325" y="160" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">模板管理页</text>
                
                <rect x="410" y="140" width="150" height="240" fill="#e8f5e9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="485" y="160" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">设置页</text>
                
                <rect x="570" y="140" width="150" height="240" fill="#f3e5f5" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="645" y="160" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">关于页</text>
                
                <!-- 状态栏 -->
                <rect x="70" y="410" width="660" height="30" fill="#eeeeee" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="400" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">状态栏</text>
                
                <!-- 小说生成页内部组件 -->
                <rect x="100" y="180" width="130" height="90" fill="#fff9c4" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="165" y="200" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">输入区 (参数设置)</text>
                
                <rect x="100" y="280" width="130" height="90" fill="#fff9c4" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="165" y="300" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">输出区 (生成结果)</text>
                
                <!-- 用户交互流向 -->
                <path d="M165,220 Q300,150 485,180" fill="none" stroke="#ff6d00" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="300" y="140" font-family="Arial" font-size="10" text-anchor="middle" fill="#ff6d00">用户操作</text>
                
                <path d="M485,280 Q300,320 165,300" fill="none" stroke="#0077c2" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="300" y="340" font-family="Arial" font-size="10" text-anchor="middle" fill="#0077c2">返回结果</text>
                
                <!-- 数据流向 -->
                <path d="M70,440 Q400,470 730,440" fill="none" stroke="#009688" stroke-width="2"/>
                <text x="400" y="480" font-family="Arial" font-size="10" text-anchor="middle" fill="#009688">状态更新流</text>
            </svg>
        </div>
        
        <h3 id="section9-2">9.2 事件处理机制</h3>
        <p>AI小说生成器采用事件驱动架构，通过回调函数处理用户交互事件：</p>
        
        <div class="code">
def setup_control_buttons(self):
    """设置控制按钮区域"""
    self.control_frame = ttk.Frame(self.input_frame)
    self.control_frame.pack(fill=tk.X, pady=10)
    
    # 创建生成按钮
    self.generate_button = ttk.Button(
        self.control_frame, 
        text="生成小说", 
        command=self.on_generate_click,
        style="Accent.TButton"
    )
    self.generate_button.pack(side=tk.LEFT, padx=5)
    
    # 创建暂停/继续按钮
    self.pause_resume_button = ttk.Button(
        self.control_frame, 
        text="暂停", 
        command=self.on_pause_resume_click,
        state=tk.DISABLED
    )
    self.pause_resume_button.pack(side=tk.LEFT, padx=5)
    
    # 创建停止按钮
    self.stop_button = ttk.Button(
        self.control_frame, 
        text="停止", 
        command=self.on_stop_click,
        state=tk.DISABLED
    )
    self.stop_button.pack(side=tk.LEFT, padx=5)
    
    # 创建保存按钮
    self.save_button = ttk.Button(
        self.control_frame, 
        text="保存", 
        command=self.on_save_click,
        state=tk.DISABLED
    )
    self.save_button.pack(side=tk.LEFT, padx=5)

def on_pause_resume_click(self):
    """暂停/继续按钮点击事件处理"""
    if not self.generator:
        return
        
    if self.generator.is_paused():
        # 如果当前是暂停状态，则恢复生成
        self.generator.resume()
        self.pause_resume_button.config(text="暂停")
        self.update_status("继续生成...")
    else:
        # 如果当前是运行状态，则暂停生成
        self.generator.pause()
        self.pause_resume_button.config(text="继续")
        self.update_status("已暂停")

def on_stop_click(self):
    """停止按钮点击事件处理"""
    if not self.generator:
        return
        
    # 确认是否停止
    if messagebox.askyesno("确认停止", "确定要停止当前生成过程吗？"):
        self.generator.stop()
        self.update_status("已停止生成")
        
        # 更新按钮状态
        self.generate_button.config(state=tk.NORMAL)
        self.pause_resume_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.DISABLED)
        
        # 如果有内容生成，启用保存按钮
        content = self.generator.get_current_content()
        if content and len(content.strip()) > 0:
            self.save_button.config(state=tk.NORMAL)

def on_model_change(self, event=None):
    """AI模型选择变化事件处理"""
    selected_model = self.model_var.get()
    
    # 根据选择的模型更新UI和参数
    if selected_model in self.model_configs:
        config = self.model_configs[selected_model]
        
        # 更新模型描述
        self.model_desc_var.set(config.get("description", ""))
        
        # 更新温度滑块
        temp_default = config.get("default_temperature", 0.7)
        self.temperature_var.set(temp_default)
        
        # 更新最大长度设置
        length_default = config.get("default_max_length", 10000)
        self.max_length_var.set(length_default)
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>回调函数</strong>：每个UI控件绑定相应的回调函数，处理用户操作。</li>
            <li><strong>状态驱动</strong>：按钮状态根据生成器状态动态更新，确保交互逻辑正确。</li>
            <li><strong>用户确认</strong>：关键操作（如停止生成）会提示用户确认，防止误操作。</li>
            <li><strong>动态更新</strong>：模型选择变化时，相关参数会自动调整为适合该模型的默认值。</li>
        </ul>
        
        <p>以下是事件处理流程的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="400" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">事件处理流程</text>
                
                <!-- 用户交互 -->
                <rect x="50" y="70" width="120" height="60" fill="#ffecb3" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="110" y="105" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">用户交互</text>
                
                <!-- 事件触发 -->
                <rect x="250" y="70" width="120" height="60" fill="#e1f5fe" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="310" y="105" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">事件触发</text>
                
                <!-- 回调函数 -->
                <rect x="450" y="70" width="120" height="60" fill="#e8f5e9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="510" y="105" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">回调函数</text>
                
                <!-- 状态更新 -->
                <rect x="650" y="70" width="120" height="60" fill="#f3e5f5" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="710" y="105" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">状态更新</text>
                
                <!-- 连接箭头 -->
                <path d="M170,100 L250,100" fill="none" stroke="#666" stroke-width="2"/>
                <polygon points="245,95 255,100 245,105" fill="#666"/>
                
                <path d="M370,100 L450,100" fill="none" stroke="#666" stroke-width="2"/>
                <polygon points="445,95 455,100 445,105" fill="#666"/>
                
                <path d="M570,100 L650,100" fill="none" stroke="#666" stroke-width="2"/>
                <polygon points="645,95 655,100 645,105" fill="#666"/>
                
                <!-- 各种具体事件 -->
                <rect x="50" y="180" width="700" height="180" fill="#ffffff" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="400" y="200" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">典型事件流程</text>
                
                <!-- 生成事件流程 -->
                <circle cx="100" cy="240" r="15" fill="#ff9800" stroke="#666" stroke-width="1"/>
                <text x="100" y="244" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">1</text>
                <text x="130" y="244" font-family="Arial" font-size="12" text-anchor="start" fill="#333">点击"生成小说"按钮</text>
                
                <circle cx="100" cy="280" r="15" fill="#ff9800" stroke="#666" stroke-width="1"/>
                <text x="100" y="284" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">2</text>
                <text x="130" y="284" font-family="Arial" font-size="12" text-anchor="start" fill="#333">调用on_generate_click()回调</text>
                
                <circle cx="100" cy="320" r="15" fill="#ff9800" stroke="#666" stroke-width="1"/>
                <text x="100" y="324" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">3</text>
                <text x="130" y="324" font-family="Arial" font-size="12" text-anchor="start" fill="#333">收集参数并启动生成器</text>
                
                <!-- 暂停事件流程 -->
                <circle cx="400" cy="240" r="15" fill="#2196f3" stroke="#666" stroke-width="1"/>
                <text x="400" y="244" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">1</text>
                <text x="430" y="244" font-family="Arial" font-size="12" text-anchor="start" fill="#333">点击"暂停/继续"按钮</text>
                
                <circle cx="400" cy="280" r="15" fill="#2196f3" stroke="#666" stroke-width="1"/>
                <text x="400" y="284" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">2</text>
                <text x="430" y="284" font-family="Arial" font-size="12" text-anchor="start" fill="#333">调用on_pause_resume_click()回调</text>
                
                <circle cx="400" cy="320" r="15" fill="#2196f3" stroke="#666" stroke-width="1"/>
                <text x="400" y="324" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">3</text>
                <text x="430" y="324" font-family="Arial" font-size="12" text-anchor="start" fill="#333">切换生成器状态并更新UI</text>
                
                <!-- 循环反馈 -->
                <path d="M710,130 Q710,360 400,360 Q100,360 100,130" fill="none" stroke="#ff5722" stroke-width="2" stroke-dasharray="5,5"/>
                <text x="400" y="380" font-family="Arial" font-size="14" text-anchor="middle" fill="#ff5722">状态更新循环反馈</text>
            </svg>
        </div>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section10">10. 数据存储分析</h2>
        <h3 id="section10-1">10.1 文件存储结构</h3>
        <p>AI小说生成器采用结构化文件存储方案，保存生成的小说内容和相关元数据：</p>
        
        <div class="code">
async def _save_final_novel(self, novel_setup, text, index=0):
    """保存最终生成的小说及其元数据"""
    try:
        # 如果没有文本，则不保存
        if not text:
            return None
        
        # 确保输出目录存在
        os.makedirs(self.output_dir, exist_ok=True)
        
        # 获取小说元数据
        novel_type = novel_setup.get("novel_type", self.novel_type)
        protagonist = novel_setup.get("protagonist", {}).get("name", "主角")
        
        # 生成时间戳
        timestamp = self.get_timestamp()
        
        # 创建基本文件名
        base_filename = f"{novel_type}_{protagonist}_{timestamp}"
        
        # 多文件生成时添加序号
        if self.num_novels > 1:
            base_filename = f"{base_filename}_{index+1}"
        
        # 构建完整文件路径
        txt_path = os.path.join(self.output_dir, f"{base_filename}.txt")
        json_path = os.path.join(self.output_dir, f"{base_filename}.json")
        html_path = os.path.join(self.output_dir, f"{base_filename}.html")
        
        # 保存纯文本版本
        with open(txt_path, 'w', encoding='utf-8') as f:
            f.write(text)
        
        # 保存元数据JSON
        with open(json_path, 'w', encoding='utf-8') as f:
            # 添加统计信息到元数据
            metadata = novel_setup.copy()
            metadata.update({
                "word_count": len(text),
                "character_count": len(text.replace("\n", "").replace(" ", "")),
                "generation_time": time.time() - self.start_time,
                "completion_timestamp": time.time(),
                "model": self.model,
                "generator_version": self.VERSION
            })
            json.dump(metadata, f, ensure_ascii=False, indent=2)
        
        # 保存HTML格式（带格式的可视化版本）
        await self._generate_html(text, novel_setup, html_path)
        
        self.update_status(f"保存完成: {txt_path}")
        return txt_path
    except Exception as e:
        error_msg = f"保存最终文件时出错: {str(e)}\n{traceback.format_exc()}"
        self.update_status(error_msg)
        return None

async def _generate_html(self, text, novel_setup, output_path):
    """生成小说的HTML可视化版本"""
    try:
        # 获取小说元数据
        title = novel_setup.get("title", "未命名小说")
        author = novel_setup.get("author", "AI小说生成器")
        novel_type = novel_setup.get("novel_type", self.novel_type)
        protagonist = novel_setup.get("protagonist", {}).get("name", "主角")
        
        # 章节划分
        chapters = text.split("\n\n第")
        first_part = chapters[0]
        rest_chapters = chapters[1:] if len(chapters) > 1 else []
        
        # 构建HTML内容
        html_content = f"""<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {
            font-family: 'Noto Serif SC', serif;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        .meta {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 0.9em;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        p {
            text-indent: 2em;
            margin-bottom: 1em;
        }
        .chapter {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <h1>{title}</h1>
    <div class="meta">
        <p>作者: {author} | 类型: {novel_type} | 主角: {protagonist}</p>
    </div>
    
    <div class="content">
        {first_part.replace("\n", "<br>")}
    """
        
        # 添加章节
        for i, chapter in enumerate(rest_chapters):
            html_content += f"""
    <div class="chapter">
        <h2>第{chapter.split("\n")[0]}</h2>
        <div>
            {"<br>".join(chapter.split("\n")[1:])}
        </div>
    </div>
            """
        
        # 结束HTML
        html_content += """
    </div>
</body>
</html>
        """
        
        # 保存HTML文件
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return output_path
    except Exception as e:
        self.update_status(f"生成HTML出错: {str(e)}")
        return None
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>多格式存储</strong>：同时保存TXT（纯文本）、JSON（元数据）和HTML（格式化可视化）三种格式，满足不同使用场景。</li>
            <li><strong>结构化命名</strong>：使用类型、主角和时间戳构建文件名，便于分类和查找。</li>
            <li><strong>异常处理</strong>：完善的异常捕获和错误报告机制，确保数据安全。</li>
            <li><strong>元数据管理</strong>：保存详细的生成参数和统计信息，便于后续分析和续写。</li>
            <li><strong>HTML可视化</strong>：自动生成格式化的HTML文件，提供更好的阅读体验。</li>
        </ul>
        
        <p>以下是数据存储结构的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="500" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">数据存储结构</text>
                
                <!-- 输出目录 -->
                <rect x="50" y="60" width="700" height="410" fill="#e3f2fd" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="400" y="80" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">输出目录 (output_dir)</text>
                
                <!-- 小说文件组 1 -->
                <rect x="80" y="100" width="300" height="160" fill="#ffffff" rx="5" ry="5" stroke="#0277bd" stroke-width="1"/>
                <text x="230" y="120" font-family="Arial" font-size="14" text-anchor="middle" fill="#0277bd">小说文件组 1</text>
                
                <!-- TXT文件 -->
                <rect x="100" y="140" width="260" height="30" fill="#bbdefb" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="130" y="160" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="150" y="160" font-family="Arial" font-size="12" fill="#333">奇幻冒险_李明_20230501.txt</text>
                
                <!-- JSON文件 -->
                <rect x="100" y="180" width="260" height="30" fill="#ffecb3" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="130" y="200" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="150" y="200" font-family="Arial" font-size="12" fill="#333">奇幻冒险_李明_20230501.json</text>
                
                <!-- HTML文件 -->
                <rect x="100" y="220" width="260" height="30" fill="#e8f5e9" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="130" y="240" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="150" y="240" font-family="Arial" font-size="12" fill="#333">奇幻冒险_李明_20230501.html</text>
                
                <!-- 小说文件组 2 -->
                <rect x="420" y="100" width="300" height="160" fill="#ffffff" rx="5" ry="5" stroke="#0277bd" stroke-width="1"/>
                <text x="570" y="120" font-family="Arial" font-size="14" text-anchor="middle" fill="#0277bd">小说文件组 2</text>
                
                <!-- TXT文件 -->
                <rect x="440" y="140" width="260" height="30" fill="#bbdefb" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="470" y="160" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="490" y="160" font-family="Arial" font-size="12" fill="#333">科幻_张伟_20230502.txt</text>
                
                <!-- JSON文件 -->
                <rect x="440" y="180" width="260" height="30" fill="#ffecb3" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="470" y="200" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="490" y="200" font-family="Arial" font-size="12" fill="#333">科幻_张伟_20230502.json</text>
                
                <!-- HTML文件 -->
                <rect x="440" y="220" width="260" height="30" fill="#e8f5e9" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="470" y="240" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="490" y="240" font-family="Arial" font-size="12" fill="#333">科幻_张伟_20230502.html</text>
                
                <!-- 自动保存文件区域 -->
                <rect x="80" y="280" width="640" height="80" fill="#ffffff" rx="5" ry="5" stroke="#ef6c00" stroke-width="1"/>
                <text x="400" y="300" font-family="Arial" font-size="14" text-anchor="middle" fill="#ef6c00">自动保存文件</text>
                
                <!-- 自动保存文件 -->
                <rect x="100" y="320" width="260" height="30" fill="#ffe0b2" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="130" y="340" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="150" y="340" font-family="Arial" font-size="12" fill="#333">悬疑_王芳_自动保存.txt</text>
                
                <!-- 自动保存元数据 -->
                <rect x="380" y="320" width="320" height="30" fill="#ffe0b2" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="410" y="340" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="430" y="340" font-family="Arial" font-size="12" fill="#333">悬疑_王芳_自动保存_meta.json</text>
                
                <!-- 错误恢复文件区域 -->
                <rect x="80" y="380" width="640" height="80" fill="#ffffff" rx="5" ry="5" stroke="#d32f2f" stroke-width="1"/>
                <text x="400" y="400" font-family="Arial" font-size="14" text-anchor="middle" fill="#d32f2f">错误恢复文件</text>
                
                <!-- 紧急保存文件 -->
                <rect x="100" y="420" width="600" height="30" fill="#ffcdd2" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="130" y="440" font-family="Arial" font-size="12" fill="#333">📄</text>
                <text x="150" y="440" font-family="Arial" font-size="12" fill="#333">emergency_save_20230503_123045.txt</text>
            </svg>
        </div>
        
        <h3 id="section10-2">10.2 元数据管理</h3>
        <p>AI小说生成器使用JSON格式保存元数据，便于存储和检索：</p>
        
        <div class="code">
def _create_novel_setup(self, index=0):
    """创建小说设置数据结构"""
    # 基本设置
    setup = {
        "title": self.title,
        "author": self.author,
        "novel_type": self.novel_type,
        "themes": self.themes.copy() if self.themes else [],
        "language": self.language,
        "creation_timestamp": time.time(),
        "index": index,
        "version": self.VERSION
    }
    
    # 添加主角设置
    if self.protagonist:
        setup["protagonist"] = self.protagonist.copy()
    
    # 添加其他角色
    if self.other_characters:
        setup["other_characters"] = self.other_characters.copy()
    
    # 添加背景设定
    if self.background_setting:
        setup["background_setting"] = self.background_setting.copy()
    
    # 添加情节需求
    if self.plot_requirements:
        setup["plot_requirements"] = self.plot_requirements.copy()
    
    # 添加生成参数
    setup["generation_params"] = {
        "model": self.model,
        "temperature": self.temperature,
        "max_length": self.max_length,
        "max_tokens": self.max_tokens,
        "top_p": self.top_p,
        "frequency_penalty": self.frequency_penalty,
        "presence_penalty": self.presence_penalty
    }
    
    # 添加随机元素
    # 根据小说类型分配不同的随机元素
    setup.update(self._add_random_elements(setup))
    
    return setup

def load_novel_metadata(self, file_path):
    """加载小说元数据"""
    try:
        # 检查文件是否存在
        if not os.path.exists(file_path):
            self.update_status(f"文件不存在: {file_path}")
            return None
        
        # 确定元数据文件路径
        if file_path.endswith('.txt'):
            # 如果是文本文件，查找对应的元数据文件
            base_name = os.path.splitext(file_path)[0]
            meta_path = f"{base_name}.json"
            
            # 如果不存在json，查找meta.json
            if not os.path.exists(meta_path):
                meta_path = f"{base_name}_meta.json"
        elif file_path.endswith('.json'):
            # 如果直接是JSON文件
            meta_path = file_path
        else:
            self.update_status(f"不支持的文件类型: {file_path}")
            return None
        
        # 加载元数据
        if os.path.exists(meta_path):
            with open(meta_path, 'r', encoding='utf-8') as f:
                metadata = json.load(f)
                self.update_status(f"已加载元数据: {meta_path}")
                return metadata
        else:
            self.update_status(f"未找到元数据文件: {meta_path}")
            
            # 尝试从文本文件提取一些基本信息
            if file_path.endswith('.txt') and os.path.exists(file_path):
                # 从文件名提取信息
                filename = os.path.basename(file_path)
                parts = os.path.splitext(filename)[0].split('_')
                
                # 构建基本元数据
                if len(parts) >= 2:
                    basic_meta = {
                        "novel_type": parts[0],
                        "protagonist": {"name": parts[1]},
                        "title": "未知标题",
                        "creation_timestamp": os.path.getctime(file_path)
                    }
                    self.update_status("已从文件名创建基本元数据")
                    return basic_meta
                
            return None
    except Exception as e:
        error_msg = f"加载元数据时出错: {str(e)}"
        self.update_status(error_msg)
        return None
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>完整元数据</strong>：保存小说的所有相关参数，包括基本信息、角色设定、情节需求和生成参数。</li>
            <li><strong>向后兼容</strong>：能够处理不同版本和不同命名格式的元数据文件。</li>
            <li><strong>失败恢复</strong>：当元数据文件缺失时，尝试从文件名和内容中提取基本信息。</li>
            <li><strong>随机增强</strong>：在元数据中添加随机元素，增加小说变化性。</li>
            <li><strong>参数完整性</strong>：确保所有必要参数都被记录，便于精确重现生成过程。</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section11">11. 配置管理分析</h2>
        <h3 id="section11-1">11.1 配置系统架构</h3>
        <p>AI小说生成器实现了灵活的配置管理系统，用于处理应用设置、模型参数和用户偏好：</p>
        
        <div class="code">
class ConfigManager:
    """配置管理类，负责加载、保存和管理程序配置"""
    
    def __init__(self, config_file="config.json"):
        """初始化配置管理器"""
        self.config_file = config_file
        self.config = self._get_default_config()
        self.load_config()
    
    def _get_default_config(self):
        """获取默认配置"""
        return {
            "app": {
                "version": "4.0.0",
                "language": "zh_CN",
                "output_dir": os.path.join(os.path.expanduser("~"), "小说生成器", "输出"),
                "templates_dir": os.path.join(os.path.expanduser("~"), "小说生成器", "模板"),
                "autosave_interval": 300,  # 自动保存间隔（秒）
                "max_history": 50,         # 最大历史记录数
                "theme": "system",         # 主题：light, dark, system
                "debug_mode": False,       # 调试模式
                "last_tab": 0,             # 上次打开的选项卡
            },
            "generation": {
                "default_model": "gpt-3.5-turbo",  # 默认模型
                "default_novel_type": "奇幻冒险",    # 默认小说类型
                "default_language": "中文",         # 默认语言
                "default_length": 5000,            # 默认字数
                "default_temperature": 0.7,        # 默认温度
                "default_top_p": 1.0,              # 默认top_p
                "default_frequency_penalty": 0.0,  # 默认频率惩罚
                "default_presence_penalty": 0.0,   # 默认存在惩罚
                "default_max_tokens": 4000,        # 默认最大令牌数
                "default_num_novels": 1,           # 默认小说数量
                "max_workers": 3,                  # 最大工作线程数
            },
            "api": {
                "provider": "openai",             # API提供商：openai, azure, etc.
                "openai_api_key": "",             # OpenAI API密钥
                "openai_endpoint": "https://api.openai.com/v1",
                "azure_api_key": "",              # Azure API密钥
                "azure_endpoint": "",             # Azure端点
                "azure_deployment": "",           # Azure部署名称
                "proxy": "",                      # 代理设置
                "timeout": 60,                    # 超时时间（秒）
                "retry_count": 3,                 # 重试次数
                "retry_delay": 5,                 # 重试延迟（秒）
            },
            "models": {
                "gpt-3.5-turbo": {
                    "name": "GPT-3.5 Turbo",
                    "provider": "openai",
                    "description": "平衡性能和效率的通用模型",
                    "max_tokens": 4000,
                    "default_temperature": 0.7,
                    "cost_per_1k_tokens": 0.002,
                    "default_max_length": 10000,
                },
                "gpt-4": {
                    "name": "GPT-4",
                    "provider": "openai",
                    "description": "高级模型，适合复杂创作",
                    "max_tokens": 8000,
                    "default_temperature": 0.8,
                    "cost_per_1k_tokens": 0.06,
                    "default_max_length": 20000,
                },
                "local-llama": {
                    "name": "本地LLaMA",
                    "provider": "local",
                    "description": "本地运行的开源大语言模型",
                    "max_tokens": 2000,
                    "default_temperature": 0.7,
                    "cost_per_1k_tokens": 0.0,
                    "default_max_length": 8000,
                    "endpoint": "http://localhost:8000/v1",
                },
                # 可以添加更多模型配置
            },
            "novel_types": [
                "奇幻冒险", "武侠", "科幻", "悬疑", "言情", "历史", "都市", "恐怖", 
                "穿越", "修真", "校园", "职场", "军事"
            ],
            "user_preferences": {
                "recent_files": [],
                "favorite_templates": [],
                "custom_themes": [],
                "last_output_dir": "",
            }
        }
    
    def load_config(self):
        """从配置文件加载配置"""
        try:
            # 如果配置文件存在
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    
                    # 递归更新配置，保留新版本中添加的默认值
                    self.config = self._update_config_recursive(self.config, loaded_config)
                    
                    logger.info(f"已加载配置: {self.config_file}")
            else:
                # 如果配置文件不存在，创建目录并保存默认配置
                os.makedirs(os.path.dirname(os.path.abspath(self.config_file)), exist_ok=True)
                self.save_config()
                logger.info(f"已创建默认配置: {self.config_file}")
        except Exception as e:
            logger.error(f"加载配置失败: {str(e)}")
            # 使用默认配置
            self.config = self._get_default_config()
    
    def _update_config_recursive(self, default_config, loaded_config):
        """递归更新配置，保留新版本中添加的默认值"""
        result = default_config.copy()
        
        for key, value in loaded_config.items():
            # 如果是字典且默认配置中也有这个键
            if isinstance(value, dict) and key in default_config and isinstance(default_config[key], dict):
                # 递归更新
                result[key] = self._update_config_recursive(default_config[key], value)
            else:
                # 直接使用加载的值
                result[key] = value
        
        return result
    
    def save_config(self):
        """保存配置到文件"""
        try:
            # 确保目录存在
            config_dir = os.path.dirname(os.path.abspath(self.config_file))
            os.makedirs(config_dir, exist_ok=True)
            
            # 保存配置
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, ensure_ascii=False, indent=2)
                
            logger.info(f"已保存配置: {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"保存配置失败: {str(e)}")
            return False
    
    def get(self, section, key=None, default=None):
        """获取配置值"""
        try:
            if key is None:
                # 如果没有提供键，返回整个部分
                return self.config.get(section, default)
            else:
                # 否则返回指定的键值
                return self.config.get(section, {}).get(key, default)
        except Exception as e:
            logger.error(f"获取配置失败: {str(e)}")
            return default
    
    def set(self, section, key, value):
        """设置配置值"""
        try:
            # 确保部分存在
            if section not in self.config:
                self.config[section] = {}
            
            # 设置值
            self.config[section][key] = value
            
            # 返回成功
            return True
        except Exception as e:
            logger.error(f"设置配置失败: {str(e)}")
            return False
    
    def update_section(self, section, values):
        """更新配置部分"""
        try:
            # 确保部分存在
            if section not in self.config:
                self.config[section] = {}
            
            # 更新值
            self.config[section].update(values)
            
            # 返回成功
            return True
        except Exception as e:
            logger.error(f"更新配置部分失败: {str(e)}")
            return False
    
    def reset_to_default(self, section=None):
        """重置配置到默认值"""
        try:
            default_config = self._get_default_config()
            
            if section is None:
                # 重置全部配置
                self.config = default_config
            else:
                # 重置指定部分
                if section in default_config:
                    self.config[section] = default_config[section]
            
            # 保存配置
            self.save_config()
            
            return True
        except Exception as e:
            logger.error(f"重置配置失败: {str(e)}")
            return False
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>分层结构</strong>：配置按功能分为应用设置、生成参数、API设置、模型配置等多个部分。</li>
            <li><strong>默认配置</strong>：提供合理的默认值，确保程序在首次运行时也能正常工作。</li>
            <li><strong>递归更新</strong>：通过递归合并新旧配置，保留用户自定义设置的同时添加新版本中的配置项。</li>
            <li><strong>异常处理</strong>：全面的错误处理机制，确保配置系统的稳定性。</li>
            <li><strong>版本兼容</strong>：能够处理不同版本的配置文件，保证向后兼容。</li>
            <li><strong>部分重置</strong>：支持重置特定部分的配置，而不影响其他设置。</li>
        </ul>
        
        <p>以下是配置系统架构的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="500" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">配置系统架构</text>
                
                <!-- 配置管理器 -->
                <rect x="300" y="60" width="200" height="60" fill="#e1f5fe" rx="5" ry="5" stroke="#0288d1" stroke-width="2"/>
                <text x="400" y="95" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">ConfigManager</text>
                
                <!-- 配置文件 -->
                <rect x="600" y="60" width="150" height="60" fill="#fff3e0" rx="5" ry="5" stroke="#e65100" stroke-width="2"/>
                <text x="675" y="95" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">config.json</text>
                
                <!-- 连接线 -->
                <path d="M500,90 L600,90" fill="none" stroke="#666" stroke-width="2"/>
                <polygon points="590,85 600,90 590,95" fill="#666"/>
                
                <!-- 配置组 -->
                <rect x="50" y="180" width="700" height="280" fill="#ffffff" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="400" y="200" font-family="Arial" font-size="16" text-anchor="middle" fill="#333">配置分组</text>
                
                <!-- 应用配置 -->
                <rect x="80" y="220" width="180" height="100" fill="#e8f5e9" rx="5" ry="5" stroke="#388e3c" stroke-width="1"/>
                <text x="170" y="240" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">应用配置 (app)</text>
                <text x="170" y="265" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">版本</text>
                <text x="170" y="285" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">语言</text>
                <text x="170" y="305" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">输出目录</text>
                
                <!-- 生成配置 -->
                <rect x="300" y="220" width="180" height="100" fill="#e8eaf6" rx="5" ry="5" stroke="#3949ab" stroke-width="1"/>
                <text x="390" y="240" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">生成配置 (generation)</text>
                <text x="390" y="265" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">默认模型</text>
                <text x="390" y="285" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">默认小说类型</text>
                <text x="390" y="305" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">生成参数</text>
                
                <!-- API配置 -->
                <rect x="520" y="220" width="180" height="100" fill="#fff8e1" rx="5" ry="5" stroke="#ffa000" stroke-width="1"/>
                <text x="610" y="240" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">API配置 (api)</text>
                <text x="610" y="265" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">API密钥</text>
                <text x="610" y="285" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">端点设置</text>
                <text x="610" y="305" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">代理设置</text>
                
                <!-- 模型配置 -->
                <rect x="80" y="340" width="300" height="100" fill="#efebe9" rx="5" ry="5" stroke="#5d4037" stroke-width="1"/>
                <text x="230" y="360" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">模型配置 (models)</text>
                <text x="230" y="385" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">GPT-3.5, GPT-4, 本地LLaMA, ...</text>
                
                <!-- 用户偏好 -->
                <rect x="400" y="340" width="300" height="100" fill="#fce4ec" rx="5" ry="5" stroke="#c2185b" stroke-width="1"/>
                <text x="550" y="360" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">用户偏好 (user_preferences)</text>
                <text x="550" y="385" font-family="Arial" font-size="12" text-anchor="middle" fill="#666">最近文件, 收藏模板, 自定义主题</text>
                
                <!-- 连接线 -->
                <path d="M400,120 L400,180" fill="none" stroke="#666" stroke-width="2"/>
                <polygon points="395,170 400,180 405,170" fill="#666"/>
            </svg>
        </div>
        
        <h3 id="section11-2">11.2 配置应用与加载</h3>
        <p>AI小说生成器通过专门的初始化流程应用配置：</p>
        
        <div class="code">
def __init__(self, root):
    """初始化应用"""
    self.root = root
    self.root.title("AI小说生成器")
    
    # 初始化配置管理器
    self.config_manager = ConfigManager()
    
    # 加载应用配置
    self.load_app_config()
    
    # 创建UI组件
    self.create_ui()
    
    # 初始化生成器
    self.init_generator()
    
    # 应用用户偏好
    self.apply_user_preferences()
    
    # 设置定时器
    self.setup_timers()

def load_app_config(self):
    """加载应用配置"""
    # 加载基本设置
    self.app_version = self.config_manager.get("app", "version", "4.0.0")
    self.language = self.config_manager.get("app", "language", "zh_CN")
    self.output_dir = self.config_manager.get("app", "output_dir", os.path.join(os.path.expanduser("~"), "小说生成器", "输出"))
    self.templates_dir = self.config_manager.get("app", "templates_dir", os.path.join(os.path.expanduser("~"), "小说生成器", "模板"))
    self.autosave_interval = self.config_manager.get("app", "autosave_interval", 300)
    self.max_history = self.config_manager.get("app", "max_history", 50)
    self.theme = self.config_manager.get("app", "theme", "system")
    self.debug_mode = self.config_manager.get("app", "debug_mode", False)
    self.last_tab = self.config_manager.get("app", "last_tab", 0)
    
    # 确保输出目录存在
    os.makedirs(self.output_dir, exist_ok=True)
    
    # 确保模板目录存在
    os.makedirs(self.templates_dir, exist_ok=True)
    
    # 加载生成设置
    self.default_model = self.config_manager.get("generation", "default_model", "gpt-3.5-turbo")
    self.default_novel_type = self.config_manager.get("generation", "default_novel_type", "奇幻冒险")
    self.default_language = self.config_manager.get("generation", "default_language", "中文")
    self.default_length = self.config_manager.get("generation", "default_length", 5000)
    self.default_temperature = self.config_manager.get("generation", "default_temperature", 0.7)
    self.default_top_p = self.config_manager.get("generation", "default_top_p", 1.0)
    self.default_frequency_penalty = self.config_manager.get("generation", "default_frequency_penalty", 0.0)
    self.default_presence_penalty = self.config_manager.get("generation", "default_presence_penalty", 0.0)
    self.default_max_tokens = self.config_manager.get("generation", "default_max_tokens", 4000)
    self.default_num_novels = self.config_manager.get("generation", "default_num_novels", 1)
    self.max_workers = self.config_manager.get("generation", "max_workers", 3)
    
    # 加载API设置
    self.api_provider = self.config_manager.get("api", "provider", "openai")
    self.openai_api_key = self.config_manager.get("api", "openai_api_key", "")
    self.openai_endpoint = self.config_manager.get("api", "openai_endpoint", "https://api.openai.com/v1")
    self.azure_api_key = self.config_manager.get("api", "azure_api_key", "")
    self.azure_endpoint = self.config_manager.get("api", "azure_endpoint", "")
    self.azure_deployment = self.config_manager.get("api", "azure_deployment", "")
    self.proxy = self.config_manager.get("api", "proxy", "")
    self.timeout = self.config_manager.get("api", "timeout", 60)
    self.retry_count = self.config_manager.get("api", "retry_count", 3)
    self.retry_delay = self.config_manager.get("api", "retry_delay", 5)
    
    # 加载模型配置
    self.models = self.config_manager.get("models", {})
    
    # 加载小说类型
    self.novel_types = self.config_manager.get("novel_types", ["奇幻冒险", "武侠", "科幻", "悬疑"])
    
    # 加载用户偏好
    self.recent_files = self.config_manager.get("user_preferences", "recent_files", [])
    self.favorite_templates = self.config_manager.get("user_preferences", "favorite_templates", [])
    self.custom_themes = self.config_manager.get("user_preferences", "custom_themes", [])
    self.last_output_dir = self.config_manager.get("user_preferences", "last_output_dir", "")

def save_app_config(self):
    """保存应用配置"""
    # 更新应用设置
    self.config_manager.update_section("app", {
        "version": self.app_version,
        "language": self.language,
        "output_dir": self.output_dir,
        "templates_dir": self.templates_dir,
        "autosave_interval": self.autosave_interval,
        "max_history": self.max_history,
        "theme": self.theme,
        "debug_mode": self.debug_mode,
        "last_tab": self.notebook.index("current") if hasattr(self, "notebook") else 0,
    })
    
    # 更新生成设置
    self.config_manager.update_section("generation", {
        "default_model": self.model_var.get() if hasattr(self, "model_var") else self.default_model,
        "default_novel_type": self.novel_type_var.get() if hasattr(self, "novel_type_var") else self.default_novel_type,
        "default_language": self.language_var.get() if hasattr(self, "language_var") else self.default_language,
        "default_length": self.length_var.get() if hasattr(self, "length_var") else self.default_length,
        "default_temperature": self.temperature_var.get() if hasattr(self, "temperature_var") else self.default_temperature,
        "default_num_novels": self.num_novels_var.get() if hasattr(self, "num_novels_var") else self.default_num_novels,
        "max_workers": self.max_workers,
    })
    
    # 更新用户偏好
    self.config_manager.update_section("user_preferences", {
        "recent_files": self.recent_files[-self.max_history:] if self.recent_files else [],
        "favorite_templates": self.favorite_templates,
        "custom_themes": self.custom_themes,
        "last_output_dir": self.output_dir_var.get() if hasattr(self, "output_dir_var") else self.last_output_dir,
    })
    
    # 保存配置
    self.config_manager.save_config()
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>配置分级</strong>：将配置按功能分组加载，便于管理和使用。</li>
            <li><strong>默认值保障</strong>：每个配置项都提供默认值，确保程序在配置缺失时能够正常运行。</li>
            <li><strong>目录自动创建</strong>：主动创建必要的目录结构，避免运行时错误。</li>
            <li><strong>状态同步</strong>：在保存配置时，从UI控件获取最新值，确保配置与实际使用状态一致。</li>
            <li><strong>保护机制</strong>：在访问UI控件前检查其是否存在，防止在初始化过程中出错。</li>
            <li><strong>记录限制</strong>：限制最近文件列表的长度，避免无限增长。</li>
        </ul>
        
        <p>此配置管理系统为AI小说生成器提供了强大的灵活性和稳定性，使用户能够根据自己的需求定制软件行为，同时确保核心功能的正常运行。</p>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section12">12. 系统整体架构</h2>
        <h3 id="section12-1">12.1 系统架构总览</h3>
        <p>AI小说生成器采用了模块化、分层的系统架构，各组件通过清晰的接口进行交互：</p>
        
        <div class="diagram">
            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="600" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">AI小说生成器系统架构</text>
                
                <!-- 用户层 -->
                <rect x="50" y="60" width="700" height="70" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="2"/>
                <text x="400" y="100" font-family="Arial" font-size="16" text-anchor="middle" fill="#1565c0">用户界面层 (UI)</text>
                
                <!-- 业务逻辑层 -->
                <rect x="50" y="150" width="700" height="200" fill="#e8f5e9" rx="5" ry="5" stroke="#2e7d32" stroke-width="2"/>
                <text x="400" y="170" font-family="Arial" font-size="16" text-anchor="middle" fill="#2e7d32">业务逻辑层 (BLL)</text>
                
                <!-- 数据访问层 -->
                <rect x="50" y="370" width="700" height="100" fill="#fff3e0" rx="5" ry="5" stroke="#e65100" stroke-width="2"/>
                <text x="400" y="390" font-family="Arial" font-size="16" text-anchor="middle" fill="#e65100">数据访问层 (DAL)</text>
                
                <!-- 外部服务层 -->
                <rect x="50" y="490" width="700" height="70" fill="#f3e5f5" rx="5" ry="5" stroke="#6a1b9a" stroke-width="2"/>
                <text x="400" y="530" font-family="Arial" font-size="16" text-anchor="middle" fill="#6a1b9a">外部服务层</text>
                
                <!-- 用户界面组件 -->
                <rect x="80" y="80" width="120" height="40" fill="#bbdefb" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="140" y="105" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">主窗口</text>
                
                <rect x="220" y="80" width="120" height="40" fill="#bbdefb" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="280" y="105" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">生成页面</text>
                
                <rect x="360" y="80" width="120" height="40" fill="#bbdefb" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="420" y="105" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">模板管理</text>
                
                <rect x="500" y="80" width="120" height="40" fill="#bbdefb" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="560" y="105" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">设置页面</text>
                
                <rect x="640" y="80" width="80" height="40" fill="#bbdefb" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="680" y="105" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">关于页</text>
                
                <!-- 业务逻辑组件 -->
                <rect x="80" y="190" width="300" height="140" fill="#c8e6c9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="230" y="210" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">小说生成核心 (NovelGenerator)</text>
                
                <!-- 小说生成核心子组件 -->
                <rect x="100" y="230" width="120" height="30" fill="#a5d6a7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="160" y="250" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">文本生成逻辑</text>
                
                <rect x="100" y="270" width="120" height="30" fill="#a5d6a7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="160" y="290" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">参数管理</text>
                
                <rect x="240" y="230" width="120" height="30" fill="#a5d6a7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="300" y="250" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">异步处理</text>
                
                <rect x="240" y="270" width="120" height="30" fill="#a5d6a7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="300" y="290" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">错误处理</text>
                
                <!-- 其他业务逻辑组件 -->
                <rect x="420" y="190" width="140" height="60" fill="#c8e6c9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="490" y="210" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">模板管理器</text>
                <text x="490" y="230" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">加载/保存模板</text>
                
                <rect x="580" y="190" width="140" height="60" fill="#c8e6c9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="650" y="210" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">配置管理器</text>
                <text x="650" y="230" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">加载/保存配置</text>
                
                <rect x="420" y="270" width="300" height="60" fill="#c8e6c9" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="570" y="290" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">API客户端</text>
                <text x="570" y="310" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">与AI服务通信</text>
                
                <!-- 数据访问组件 -->
                <rect x="80" y="400" width="140" height="50" fill="#ffe0b2" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="150" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">文件存储管理</text>
                
                <rect x="240" y="400" width="140" height="50" fill="#ffe0b2" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="310" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">元数据管理</text>
                
                <rect x="400" y="400" width="140" height="50" fill="#ffe0b2" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="470" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">配置文件操作</text>
                
                <rect x="560" y="400" width="140" height="50" fill="#ffe0b2" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="630" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">日志系统</text>
                
                <!-- 外部服务组件 -->
                <rect x="80" y="510" width="140" height="30" fill="#e1bee7" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="150" y="530" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">OpenAI API</text>
                
                <rect x="240" y="510" width="140" height="30" fill="#e1bee7" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="310" y="530" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">Azure OpenAI</text>
                
                <rect x="400" y="510" width="140" height="30" fill="#e1bee7" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="470" y="530" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">本地LLM</text>
                
                <rect x="560" y="510" width="140" height="30" fill="#e1bee7" rx="5" ry="5" stroke="#666" stroke-width="1"/>
                <text x="630" y="530" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">文件系统</text>
                
                <!-- 连接线 - 用户界面到业务逻辑 -->
                <path d="M140,120 L140,190" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M280,120 L280,190" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M420,120 L420,190" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M560,120 L560,190" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                
                <!-- 连接线 - 业务逻辑到数据访问 -->
                <path d="M150,330 L150,400" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M310,330 L310,400" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M470,330 L470,400" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M630,330 L630,400" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                
                <!-- 连接线 - 数据访问到外部服务 -->
                <path d="M150,450 L150,510" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M310,450 L310,510" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M470,450 L470,510" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                <path d="M630,450 L630,510" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="5,2"/>
                
                <!-- 数据流向 -->
                <path d="M50,45 L750,45" fill="none" stroke="#f44336" stroke-width="2"/>
                <polygon points="740,40 750,45 740,50" fill="#f44336"/>
                <text x="400" y="60" font-family="Arial" font-size="10" text-anchor="middle" fill="#f44336">数据流向</text>
            </svg>
        </div>
        
        <p>系统架构分析：</p>
        <ul>
            <li><strong>分层架构</strong>：整个系统采用经典的四层架构，包括用户界面层(UI)、业务逻辑层(BLL)、数据访问层(DAL)和外部服务层。</li>
            <li><strong>核心组件</strong>：NovelGenerator为核心组件，实现小说生成的主要业务逻辑，包括文本生成、参数管理、异步处理和错误处理。</li>
            <li><strong>模块化设计</strong>：系统被分解为多个功能独立的模块，每个模块负责特定的功能，如模板管理、配置管理和API客户端。</li>
            <li><strong>数据流向</strong>：用户通过UI层输入参数，业务逻辑层处理核心生成算法，数据访问层负责存储和检索，外部服务层提供AI能力和文件操作。</li>
            <li><strong>解耦合设计</strong>：各层之间通过定义良好的接口进行通信，降低了模块间的耦合度，提高了系统的可维护性和可扩展性。</li>
        </ul>
        
        <h3 id="section12-2">12.2 程序启动与初始化流程</h3>
        <p>AI小说生成器实现了健壮的启动和初始化机制，确保程序在不同环境下都能正确加载：</p>
        
        <div class="code">
import os
import sys
import logging
import traceback
import importlib.util

# 设置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('novel_generator.log', encoding='utf-8')
    ]
)
logger = logging.getLogger("novel_generator")

# 添加调试信息
logger.info(f"当前工作目录: {os.getcwd()}")

# 检测是否在打包环境中运行
is_frozen = getattr(sys, 'frozen', False)
if is_frozen:
    # 运行在PyInstaller打包的环境中
    base_dir = getattr(sys, '_MEIPASS', os.path.dirname(sys.executable))
    logger.info(f"运行在打包环境中，基础目录: {base_dir}")
else:
    # 运行在开发环境中
    base_dir = os.path.dirname(os.path.abspath(__file__))
    logger.info(f"运行在开发环境中，基础目录: {base_dir}")

# 添加项目根目录到Python路径，确保导入正常工作
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)

# 确保当前目录也在路径中
paths_to_add = [
    current_dir, 
    parent_dir,
    os.path.join(base_dir, 'ui'),
    os.path.join(base_dir, 'core'),
    os.path.join(base_dir, 'utils'),
    os.path.join(base_dir, 'templates')
]

for path in paths_to_add:
    if os.path.exists(path) and path not in sys.path:
        sys.path.insert(0, path)
        logger.info(f"添加路径到sys.path: {path}")

logger.info(f"Python路径: {sys.path}")

# 添加ctypes导入，用于设置应用ID和去除黑窗口
try:
    import ctypes
    if sys.platform.startswith('win'):
        # 设置应用ID，使任务栏图标正确显示
        app_id = 'novel_generator.app'
        try:
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(app_id)
            logger.info("已设置Windows应用ID")
        except Exception as e:
            logger.warning(f"设置Windows应用ID失败: {str(e)}")
except ImportError:
    logger.warning("无法导入ctypes模块")

def main():
    """
    主程序入口，启动GUI应用
    """
    import tkinter as tk
    from tkinter import messagebox
    
    logger.info("AI小说生成器启动")
    
    try:
        root = tk.Tk()
        # 设置窗口尺寸
        root.geometry("1280x860")  # 增加窗口大小
        root.minsize(1200, 800)    # 设置最小尺寸
        
        # 设置窗口图标
        try:
            # 尝试多个可能的图标路径
            icon_paths = [
                os.path.join(os.path.dirname(__file__), "resources", "icon.ico"),
                os.path.join(base_dir, "resources", "icon.ico"),
                "resources/icon.ico"
            ]
            
            icon_found = False
            for icon_path in icon_paths:
                if os.path.exists(icon_path):
                    root.iconbitmap(icon_path)
                    logger.info(f"已设置应用图标: {icon_path}")
                    icon_found = True
                    break
            
            if not icon_found:
                import warnings
                warnings.warn("未找到可用的应用图标")
        except Exception as e:
            logger.warning(f"设置应用图标失败: {str(e)}")
            
        # 导入UI模块
        try:
            from ui.app import NovelGeneratorApp
            logger.info("成功导入UI模块")
        except ImportError as e:
            logger.error(f"UI模块导入失败: {str(e)}")
            messagebox.showerror("错误", f"无法加载UI模块: {str(e)}\n请确保程序完整安装。")
            sys.exit(1)
            
        app = NovelGeneratorApp(root)
        root.protocol("WM_DELETE_WINDOW", app.on_closing)
        logger.info("应用界面已初始化")
        
        root.mainloop()
        logger.info("应用已关闭")
    except Exception as e:
        error_msg = f"应用运行出错: {str(e)}"
        logger.error(f"{error_msg}\n{traceback.format_exc()}")
        
        try:
            messagebox.showerror("错误", error_msg)
        except:
            print(error_msg)
            
        input("按Enter键退出...")
        sys.exit(1)
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>环境检测</strong>：检测程序运行环境（开发环境或打包环境），确保路径设置正确。</li>
            <li><strong>路径配置</strong>：动态添加必要的模块路径到Python系统路径，确保模块导入正常。</li>
            <li><strong>日志系统</strong>：建立完整的日志记录机制，详细记录程序启动和运行过程。</li>
            <li><strong>平台适配</strong>：根据不同操作系统平台进行特定配置，如Windows下设置应用ID。</li>
            <li><strong>错误捕获</strong>：全面的异常处理机制，确保任何错误都能被捕获并向用户提供友好提示。</li>
            <li><strong>资源定位</strong>：灵活查找应用资源（如图标文件），支持多种可能的路径。</li>
            <li><strong>优雅退出</strong>：确保程序在发生错误时能够优雅地退出，避免用户数据丢失。</li>
        </ul>
        
        <p>以下是程序启动流程的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="500" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">程序启动与初始化流程</text>
                
                <!-- 流程图形状 -->
                <!-- 开始 -->
                <ellipse cx="400" cy="70" rx="70" ry="30" fill="#e8f5e9" stroke="#2e7d32" stroke-width="2"/>
                <text x="400" y="75" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">程序启动</text>
                
                <!-- 日志初始化 -->
                <rect x="330" y="120" width="140" height="40" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="400" y="145" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">日志系统初始化</text>
                
                <!-- 环境检测 -->
                <rect x="330" y="180" width="140" height="40" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="400" y="205" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">环境检测</text>
                
                <!-- 分支 -->
                <polygon points="400,240 430,270 400,300 370,270" fill="#fff3e0" stroke="#e65100" stroke-width="1"/>
                <text x="400" y="275" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">打包环境?</text>
                
                <!-- 不同环境处理 -->
                <rect x="230" y="320" width="140" height="40" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="300" y="345" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">开发环境路径配置</text>
                
                <rect x="430" y="320" width="140" height="40" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="500" y="345" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">打包环境路径配置</text>
                
                <!-- 模块导入 -->
                <rect x="330" y="380" width="140" height="40" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="400" y="405" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">GUI初始化</text>
                
                <!-- 结束 -->
                <ellipse cx="400" cy="450" rx="70" ry="30" fill="#e8f5e9" stroke="#2e7d32" stroke-width="2"/>
                <text x="400" y="455" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">应用主循环</text>
                
                <!-- 连接线 -->
                <line x1="400" y1="100" x2="400" y2="120" stroke="#666" stroke-width="1"/>
                <polygon points="395,115 400,120 405,115" fill="#666"/>
                
                <line x1="400" y1="160" x2="400" y2="180" stroke="#666" stroke-width="1"/>
                <polygon points="395,175 400,180 405,175" fill="#666"/>
                
                <line x1="400" y1="220" x2="400" y2="240" stroke="#666" stroke-width="1"/>
                <polygon points="395,235 400,240 405,235" fill="#666"/>
                
                <line x1="370" y1="270" x2="300" y2="320" stroke="#666" stroke-width="1"/>
                <polygon points="302,315 300,320 308,318" fill="#666"/>
                <text x="320" y="290" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">否</text>
                
                <line x1="430" y1="270" x2="500" y2="320" stroke="#666" stroke-width="1"/>
                <polygon points="492,318 500,320 498,315" fill="#666"/>
                <text x="480" y="290" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">是</text>
                
                <line x1="300" y1="360" x2="400" y2="380" stroke="#666" stroke-width="1"/>
                <polygon points="395,375 400,380 395,385" fill="#666"/>
                
                <line x1="500" y1="360" x2="400" y2="380" stroke="#666" stroke-width="1"/>
                <polygon points="405,375 400,380 405,385" fill="#666"/>
                
                <line x1="400" y1="420" x2="400" y2="420" stroke="#666" stroke-width="1"/>
                <line x1="400" y1="420" x2="400" y2="450" stroke="#666" stroke-width="1"/>
                <polygon points="395,445 400,450 405,445" fill="#666"/>
                
                <!-- 错误处理流程 -->
                <rect x="600" y="180" width="140" height="40" fill="#ffebee" rx="5" ry="5" stroke="#c62828" stroke-width="1"/>
                <text x="670" y="205" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">异常处理</text>
                
                <rect x="600" y="240" width="140" height="40" fill="#ffebee" rx="5" ry="5" stroke="#c62828" stroke-width="1"/>
                <text x="670" y="265" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">错误日志记录</text>
                
                <rect x="600" y="300" width="140" height="40" fill="#ffebee" rx="5" ry="5" stroke="#c62828" stroke-width="1"/>
                <text x="670" y="325" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">用户错误提示</text>
                
                <ellipse cx="670" cy="370" rx="70" ry="30" fill="#ffebee" stroke="#c62828" stroke-width="2"/>
                <text x="670" y="375" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">程序退出</text>
                
                <!-- 错误处理连接线 -->
                <path d="M470,205 Q530,205 600,205" fill="none" stroke="#c62828" stroke-width="1" stroke-dasharray="5,2"/>
                <text x="530" y="195" font-family="Arial" font-size="12" text-anchor="middle" fill="#c62828">异常发生</text>
                
                <line x1="670" y1="220" x2="670" y2="240" stroke="#c62828" stroke-width="1"/>
                <polygon points="665,235 670,240 675,235" fill="#c62828"/>
                
                <line x1="670" y1="280" x2="670" y2="300" stroke="#c62828" stroke-width="1"/>
                <polygon points="665,295 670,300 675,295" fill="#c62828"/>
                
                <line x1="670" y1="340" x2="670" y2="340" stroke="#c62828" stroke-width="1"/>
                <line x1="670" y1="340" x2="670" y2="370" stroke="#c62828" stroke-width="1"/>
                <polygon points="665,365 670,370 675,365" fill="#c62828"/>
            </svg>
        </div>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section13">13. 测试与质量保障</h2>
        <h3 id="section13-1">13.1 测试策略</h3>
        <p>AI小说生成器采用多层次的测试策略，确保软件质量和用户体验：</p>
        
        <div class="code">
class TestNovelGenerator(unittest.TestCase):
    """小说生成器测试类"""
    
    @classmethod
    def setUpClass(cls):
        """测试类初始化，只执行一次"""
        # 设置测试环境
        cls.test_output_dir = os.path.join(tempfile.gettempdir(), "novel_generator_test")
        os.makedirs(cls.test_output_dir, exist_ok=True)
        
        # 设置测试配置
        cls.test_config = {
            "api_key": os.environ.get("OPENAI_API_KEY", ""),
            "model": "gpt-3.5-turbo",
            "temperature": 0.7,
            "max_tokens": 500,
            "output_dir": cls.test_output_dir
        }
        
        # 如果没有API密钥，使用模拟模式
        if not cls.test_config["api_key"]:
            cls.mock_mode = True
            print("警告: 未设置API密钥，测试将在模拟模式下运行")
        else:
            cls.mock_mode = False
    
    @classmethod
    def tearDownClass(cls):
        """测试类清理，只执行一次"""
        # 清理测试目录
        try:
            shutil.rmtree(cls.test_output_dir)
        except Exception as e:
            print(f"清理测试目录时出错: {e}")
    
    def setUp(self):
        """每个测试方法前执行"""
        # 创建生成器实例
        if self.mock_mode:
            # 使用模拟API的生成器
            self.generator = MockNovelGenerator(
                output_dir=self.test_output_dir,
                model=self.test_config["model"],
                temperature=self.test_config["temperature"],
                max_tokens=self.test_config["max_tokens"]
            )
        else:
            # 使用真实API的生成器
            self.generator = NovelGenerator(
                output_dir=self.test_output_dir,
                api_key=self.test_config["api_key"],
                model=self.test_config["model"],
                temperature=self.test_config["temperature"],
                max_tokens=self.test_config["max_tokens"]
            )
    
    def tearDown(self):
        """每个测试方法后执行"""
        # 停止生成器
        if hasattr(self, 'generator') and self.generator:
            self.generator.stop()
            
        # 清理临时文件
        for file in os.listdir(self.test_output_dir):
            try:
                os.remove(os.path.join(self.test_output_dir, file))
            except:
                pass
    
    @unittest.skipIf(os.environ.get("SKIP_API_TESTS"), "跳过API测试")
    async def test_basic_generation(self):
        """测试基本小说生成功能"""
        # 设置参数
        self.generator.novel_type = "奇幻冒险"
        self.generator.title = "测试小说"
        self.generator.author = "测试作者"
        self.generator.num_novels = 1
        self.generator.max_length = 1000
        
        # 执行生成
        result = await self.generator.generate_novels()
        
        # 验证结果
        self.assertIsNotNone(result, "生成结果不应为None")
        self.assertIsInstance(result, list, "结果应该是列表")
        
        if result:
            self.assertTrue(os.path.exists(result[0]), f"生成的文件应该存在: {result[0]}")
            
            # 验证文件内容
            with open(result[0], 'r', encoding='utf-8') as f:
                content = f.read()
                self.assertTrue(len(content) > 0, "生成的内容不应为空")
                self.assertIn("奇幻冒险", content, "内容应该包含小说类型")
    
    def test_parameter_validation(self):
        """测试参数验证功能"""
        # 测试无效温度
        with self.assertRaises(ValueError):
            self.generator.temperature = 2.5
        
        # 测试无效的小说数量
        with self.assertRaises(ValueError):
            self.generator.num_novels = -1
        
        # 测试有效参数
        self.generator.temperature = 0.8
        self.assertEqual(self.generator.temperature, 0.8)
        
        self.generator.max_length = 5000
        self.assertEqual(self.generator.max_length, 5000)
    
    @unittest.skipIf(os.environ.get("SKIP_LONG_TESTS"), "跳过长时间测试")
    async def test_multiple_generation(self):
        """测试多小说并行生成功能"""
        # 设置参数
        self.generator.novel_type = "科幻"
        self.generator.title = "测试多小说"
        self.generator.num_novels = 3
        self.generator.max_length = 500
        self.generator.max_workers = 2
        
        # 执行生成
        result = await self.generator.generate_novels()
        
        # 验证结果
        self.assertIsNotNone(result, "生成结果不应为None")
        self.assertIsInstance(result, list, "结果应该是列表")
        self.assertLessEqual(len(result), 3, "结果数量应该小于等于请求数量")
        
        # 检查文件
        for file_path in result:
            if file_path:
                self.assertTrue(os.path.exists(file_path), f"生成的文件应该存在: {file_path}")
    
    async def test_pause_resume(self):
        """测试暂停和恢复功能"""
        # 设置参数
        self.generator.novel_type = "悬疑"
        self.generator.max_length = 1000
        
        # 启动生成
        generation_task = asyncio.create_task(self.generator.generate_novels())
        
        # 等待生成开始
        await asyncio.sleep(0.5)
        
        # 测试暂停
        self.assertTrue(self.generator.pause(), "应该能够暂停")
        self.assertTrue(self.generator.is_paused(), "暂停后状态应为暂停")
        
        # 测试恢复
        self.assertTrue(self.generator.resume(), "应该能够恢复")
        self.assertFalse(self.generator.is_paused(), "恢复后状态应为非暂停")
        
        # 测试停止
        self.assertTrue(self.generator.stop(), "应该能够停止")
        self.assertFalse(self.generator.is_running(), "停止后应该不在运行")
        
        # 等待任务完成
        try:
            await asyncio.wait_for(generation_task, timeout=2)
        except asyncio.TimeoutError:
            self.fail("生成任务在停止后没有正确结束")
            
    def test_error_handling(self):
        """测试错误处理机制"""
        # 设置无效API密钥
        if not self.mock_mode:
            self.generator.api_key = "invalid_key"
        
        # 执行生成，应该能捕获API错误
        async def run_generation():
            return await self.generator.generate_novels()
        
        result = asyncio.run(run_generation())
        
        # 验证结果为空但不会崩溃
        self.assertEqual(result, [], "错误情况下应返回空列表")
</div>

        <p>代码分析：</p>
        <ul>
            <li><strong>单元测试</strong>：使用Python标准库unittest框架，对小说生成器的核心功能进行测试。</li>
            <li><strong>环境适应性</strong>：支持真实API测试和模拟模式测试，可在不同环境下执行。</li>
            <li><strong>参数验证</strong>：测试程序对无效参数的验证能力，确保数据安全。</li>
            <li><strong>异步测试</strong>：针对异步生成过程的专门测试，验证暂停/恢复/停止等功能。</li>
            <li><strong>错误处理</strong>：测试程序在API错误等异常情况下的恢复能力。</li>
            <li><strong>资源清理</strong>：确保测试过程中创建的临时文件被正确清理。</li>
        </ul>
        
        <p>AI小说生成器的测试策略图：</p>
        <div class="diagram">
            <svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="400" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">测试策略层次图</text>
                
                <!-- 金字塔形状 -->
                <polygon points="200,70 600,70 550,350 250,350" fill="#e8f5e9" stroke="#2e7d32" stroke-width="2"/>
                
                <!-- 金字塔层次 -->
                <line x1="220" y1="130" x2="580" y2="130" stroke="#333" stroke-width="1"/>
                <line x1="240" y1="190" x2="560" y2="190" stroke="#333" stroke-width="1"/>
                <line x1="260" y1="250" x2="540" y2="250" stroke="#333" stroke-width="1"/>
                <line x1="280" y1="310" x2="520" y2="310" stroke="#333" stroke-width="1"/>
                
                <!-- 层次标签 -->
                <text x="400" y="110" font-family="Arial" font-size="16" text-anchor="middle" fill="#d32f2f">单元测试</text>
                <text x="400" y="170" font-family="Arial" font-size="16" text-anchor="middle" fill="#e65100">集成测试</text>
                <text x="400" y="230" font-family="Arial" font-size="16" text-anchor="middle" fill="#2e7d32">功能测试</text>
                <text x="400" y="290" font-family="Arial" font-size="16" text-anchor="middle" fill="#1565c0">系统测试</text>
                <text x="400" y="340" font-family="Arial" font-size="16" text-anchor="middle" fill="#6a1b9a">用户验收测试</text>
                
                <!-- 单元测试项目 -->
                <rect x="150" y="80" width="120" height="20" fill="#ffcdd2" rx="5" ry="5" stroke="#d32f2f" stroke-width="1"/>
                <text x="210" y="94" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">参数验证测试</text>
                
                <rect x="290" y="80" width="120" height="20" fill="#ffcdd2" rx="5" ry="5" stroke="#d32f2f" stroke-width="1"/>
                <text x="350" y="94" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">模型交互测试</text>
                
                <rect x="430" y="80" width="120" height="20" fill="#ffcdd2" rx="5" ry="5" stroke="#d32f2f" stroke-width="1"/>
                <text x="490" y="94" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">错误处理测试</text>
                
                <rect x="570" y="80" width="120" height="20" fill="#ffcdd2" rx="5" ry="5" stroke="#d32f2f" stroke-width="1"/>
                <text x="630" y="94" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">数据存储测试</text>
                
                <!-- 集成测试项目 -->
                <rect x="180" y="140" width="130" height="20" fill="#ffe0b2" rx="5" ry="5" stroke="#e65100" stroke-width="1"/>
                <text x="245" y="154" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">API集成测试</text>
                
                <rect x="330" y="140" width="130" height="20" fill="#ffe0b2" rx="5" ry="5" stroke="#e65100" stroke-width="1"/>
                <text x="395" y="154" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">多线程协作测试</text>
                
                <rect x="480" y="140" width="130" height="20" fill="#ffe0b2" rx="5" ry="5" stroke="#e65100" stroke-width="1"/>
                <text x="545" y="154" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">UI与核心集成测试</text>
                
                <!-- 功能测试项目 -->
                <rect x="210" y="200" width="180" height="20" fill="#c8e6c9" rx="5" ry="5" stroke="#2e7d32" stroke-width="1"/>
                <text x="300" y="214" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">基本生成功能测试</text>
                
                <rect x="410" y="200" width="180" height="20" fill="#c8e6c9" rx="5" ry="5" stroke="#2e7d32" stroke-width="1"/>
                <text x="500" y="214" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">高级生成功能测试</text>
                
                <!-- 系统测试项目 -->
                <rect x="240" y="260" width="320" height="20" fill="#bbdefb" rx="5" ry="5" stroke="#1565c0" stroke-width="1"/>
                <text x="400" y="274" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">完整工作流程测试</text>
                
                <!-- 用户验收测试 -->
                <rect x="270" y="320" width="260" height="20" fill="#e1bee7" rx="5" ry="5" stroke="#6a1b9a" stroke-width="1"/>
                <text x="400" y="334" font-family="Arial" font-size="10" text-anchor="middle" fill="#333">用户场景测试</text>
                
                <!-- 测试数量标注 -->
                <text x="700" y="94" font-family="Arial" font-size="12" text-anchor="start" fill="#333">50+ 测试</text>
                <text x="700" y="154" font-family="Arial" font-size="12" text-anchor="start" fill="#333">20+ 测试</text>
                <text x="700" y="214" font-family="Arial" font-size="12" text-anchor="start" fill="#333">15+ 测试</text>
                <text x="700" y="274" font-family="Arial" font-size="12" text-anchor="start" fill="#333">10+ 测试</text>
                <text x="700" y="334" font-family="Arial" font-size="12" text-anchor="start" fill="#333">5+ 测试</text>
            </svg>
        </div>
        
        <h3 id="section13-2">13.2 测试用例示例</h3>
        <p>AI小说生成器测试覆盖了以下主要测试场景：</p>
        
        <table class="test-table">
            <tr>
                <th>测试类别</th>
                <th>测试场景</th>
                <th>测试步骤</th>
                <th>预期结果</th>
            </tr>
            <tr>
                <td>单元测试</td>
                <td>参数验证</td>
                <td>
                    1. 设置无效的温度参数 (>1)<br>
                    2. 设置无效的小说数量 (-1)<br>
                    3. 设置有效的参数
                </td>
                <td>
                    1. 抛出ValueError异常<br>
                    2. 抛出ValueError异常<br>
                    3. 参数正确设置
                </td>
            </tr>
            <tr>
                <td>功能测试</td>
                <td>基本小说生成</td>
                <td>
                    1. 设置小说类型为"奇幻冒险"<br>
                    2. 设置标题和作者<br>
                    3. 调用generate_novels()方法
                </td>
                <td>
                    1. 生成结果非空<br>
                    2. 生成文件存在<br>
                    3. 文件内容包含"奇幻冒险"
                </td>
            </tr>
            <tr>
                <td>集成测试</td>
                <td>多线程生成</td>
                <td>
                    1. 设置num_novels=3<br>
                    2. 设置max_workers=2<br>
                    3. 调用generate_novels()方法
                </td>
                <td>
                    1. 返回结果为列表<br>
                    2. 列表长度≤3<br>
                    3. 所有返回的文件路径都存在
                </td>
            </tr>
            <tr>
                <td>功能测试</td>
                <td>暂停/恢复</td>
                <td>
                    1. 启动小说生成<br>
                    2. 调用pause()方法<br>
                    3. 调用resume()方法<br>
                    4. 调用stop()方法
                </td>
                <td>
                    1. pause()返回True<br>
                    2. is_paused()返回True<br>
                    3. resume后is_paused()返回False<br>
                    4. stop后is_running()返回False
                </td>
            </tr>
            <tr>
                <td>错误处理</td>
                <td>API错误恢复</td>
                <td>
                    1. 设置无效的API密钥<br>
                    2. 调用generate_novels()方法
                </td>
                <td>
                    1. 方法不抛出未捕获异常<br>
                    2. 返回空列表<br>
                    3. 程序状态正确恢复
                </td>
            </tr>
            <tr>
                <td>系统测试</td>
                <td>界面集成</td>
                <td>
                    1. 通过UI设置参数<br>
                    2. 点击生成按钮<br>
                    3. 等待生成完成<br>
                    4. 检查输出区域
                </td>
                <td>
                    1. 参数正确传递到生成器<br>
                    2. 生成过程正常启动<br>
                    3. UI状态随生成过程更新<br>
                    4. 生成结果显示在输出区域
                </td>
            </tr>
        </table>
        
        <h3 id="section13-3">13.3 自动化测试流水线</h3>
        <p>AI小说生成器的持续集成流水线配置：</p>
        
        <div class="code">
name: AI Novel Generator CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        python-version: [3.8, 3.9, '3.10']
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest pytest-asyncio
        pip install -r requirements.txt
    
    - name: Lint with flake8
      run: |
        # 停止在严重错误上
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # 将警告作为错误
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Test with pytest (mock mode)
      run: |
        pytest tests/ --cov=novel_generator -v
      env:
        SKIP_API_TESTS: true
    
    - name: Build application package
      if: matrix.os == 'windows-latest' && matrix.python-version == '3.9'
      run: |
        pip install pyinstaller
        pyinstaller --onefile --windowed --name novel_generator --icon=resources/icon.ico main.py
</div>

        <p>测试流水线分析：</p>
        <ul>
            <li><strong>跨平台测试</strong>：在Windows、macOS和Ubuntu上进行测试，确保软件在各平台上正常工作。</li>
            <li><strong>多Python版本</strong>：测试在Python 3.8、3.9和3.10版本上的兼容性。</li>
            <li><strong>代码质量检查</strong>：使用flake8进行代码质量检查，确保代码符合规范。</li>
            <li><strong>自动化测试</strong>：使用pytest进行自动化测试，包括单元测试和集成测试。</li>
            <li><strong>构建测试</strong>：在Windows环境下使用PyInstaller进行应用打包测试。</li>
            <li><strong>模拟模式</strong>：测试时使用模拟模式，避免对实际API的依赖。</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section14">14. 部署与发布流程</h2>
        <h3 id="section14-1">14.1 应用打包流程</h3>
        <p>AI小说生成器使用PyInstaller进行跨平台打包，确保在不同操作系统上正常运行：</p>
        
        <div class="code">
# build_app.py - 应用打包脚本

import os
import sys
import shutil
import subprocess
import platform
import argparse

def parse_args():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description="AI小说生成器打包脚本")
    parser.add_argument('--clean', action='store_true', help='清理构建目录')
    parser.add_argument('--dist-only', action='store_true', help='仅生成分发包')
    parser.add_argument('--version', type=str, default='1.0.0', help='应用版本号')
    parser.add_argument('--output', type=str, default='dist', help='输出目录')
    return parser.parse_args()

def clean_build_dirs():
    """清理构建目录"""
    print("清理构建目录...")
    dirs_to_clean = ['build', 'dist', '__pycache__']
    for dir_name in dirs_to_clean:
        if os.path.exists(dir_name):
            shutil.rmtree(dir_name)
            print(f"- 已删除 {dir_name}/")
    
    # 删除spec文件
    for spec_file in os.listdir('.'):
        if spec_file.endswith('.spec'):
            os.remove(spec_file)
            print(f"- 已删除 {spec_file}")

def collect_resources():
    """收集资源文件"""
    print("收集资源文件...")
    resources = {
        'icons': ['resources/icon.ico', 'resources/icon.png'],
        'templates': ['templates/奇幻冒险.json', 'templates/科幻.json', 'templates/悬疑.json'],
        'doc': ['README.md', 'LICENSE']
    }
    
    # 确保资源文件存在
    missing_files = []
    for category, files in resources.items():
        for file_path in files:
            if not os.path.exists(file_path):
                missing_files.append(file_path)
    
    if missing_files:
        print("警告: 以下资源文件缺失:")
        for file_path in missing_files:
            print(f"- {file_path}")
        
        user_input = input("是否继续打包? (y/n): ")
        if user_input.lower() != 'y':
            sys.exit(1)
    
    return resources

def create_pyinstaller_command(args, resources):
    """创建PyInstaller命令"""
    # 基本命令
    cmd = ['pyinstaller', '--noconfirm', '--clean']
    
    # 添加图标
    icon_path = resources['icons'][0] if resources['icons'] else None
    if icon_path and os.path.exists(icon_path):
        cmd.extend(['--icon', icon_path])
    
    # 添加窗口模式
    if platform.system() == 'Windows':
        cmd.append('--windowed')  # 在Windows上隐藏控制台窗口
    
    # 添加名称和版本
    cmd.extend(['--name', f'AI小说生成器-v{args.version}'])
    
    # 添加其他选项
    cmd.extend([
        '--add-data', f'resources{os.pathsep}resources',
        '--add-data', f'templates{os.pathsep}templates',
    ])
    
    # 添加主脚本
    cmd.append('main.py')
    
    return cmd

def build_application(args):
    """构建应用程序"""
    print(f"开始构建 AI小说生成器 v{args.version}...")
    
    # 收集资源
    resources = collect_resources()
    
    # 创建PyInstaller命令
    cmd = create_pyinstaller_command(args, resources)
    
    # 执行构建
    print(f"执行命令: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    # 检查结果
    if result.returncode != 0:
        print("构建失败:")
        print(result.stderr)
        return False
    
    print("构建成功!")
    
    # 如果仅生成分发包，则打包dist目录
    if args.dist_only:
        create_distribution_package(args, resources)
    
    return True

def create_distribution_package(args, resources):
    """创建分发包"""
    print("创建分发包...")
    
    # 确定输出目录
    output_dir = args.output
    os.makedirs(output_dir, exist_ok=True)
    
    # 确定应用名称
    app_name = f'AI小说生成器-v{args.version}'
    
    # 压缩dist目录
    if platform.system() == 'Windows':
        # 在Windows上使用ZIP
        import zipfile
        zip_path = os.path.join(output_dir, f'{app_name}-win.zip')
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk('dist'):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, 'dist')
                    zipf.write(file_path, arcname)
        print(f"已创建分发包: {zip_path}")
    else:
        # 在Linux/Mac上使用tar.gz
        import tarfile
        tar_path = os.path.join(output_dir, f'{app_name}-{"mac" if platform.system() == "Darwin" else "linux"}.tar.gz')
        with tarfile.open(tar_path, 'w:gz') as tar:
            tar.add('dist', arcname=app_name)
        print(f"已创建分发包: {tar_path}")

def main():
    """主函数"""
    args = parse_args()
    
    # 如果需要清理，先清理
    if args.clean:
        clean_build_dirs()
    
    # 构建应用
    success = build_application(args)
    
    if success:
        print(f"AI小说生成器 v{args.version} 构建完成!")
    else:
        print("构建失败，请检查错误信息。")
        sys.exit(1)

if __name__ == "__main__":
    main()
</div>

        <p>打包流程分析：</p>
        <ul>
            <li><strong>资源收集</strong>：在打包前自动收集所有必要的资源文件，确保完整性。</li>
            <li><strong>跨平台支持</strong>：根据不同的操作系统自动调整打包选项和输出格式。</li>
            <li><strong>命令行参数</strong>：提供丰富的命令行参数，支持清理、仅打包等不同选项。</li>
            <li><strong>错误检测</strong>：检查资源文件完整性，提供用户确认机制。</li>
            <li><strong>分发包创建</strong>：自动创建适合各平台的分发包（Windows为zip，Linux/Mac为tar.gz）。</li>
            <li><strong>版本管理</strong>：支持指定版本号，便于版本控制和跟踪。</li>
        </ul>
        
        <p>以下是应用打包流程的SVG示意图：</p>
        <div class="diagram">
            <svg width="800" height="500" xmlns="http://www.w3.org/2000/svg">
                <!-- 图表背景 -->
                <rect width="800" height="500" fill="#f9f9f9" rx="10" ry="10" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="20" text-anchor="middle" fill="#333">应用打包流程</text>
                
                <!-- 流程图形状 -->
                <!-- 阶段1：准备 -->
                <rect x="100" y="70" width="600" height="80" fill="#e3f2fd" rx="5" ry="5" stroke="#1565c0" stroke-width="2"/>
                <text x="400" y="90" font-family="Arial" font-size="16" text-anchor="middle" fill="#1565c0">准备阶段</text>
                
                <!-- 准备阶段步骤 -->
                <rect x="120" y="110" width="170" height="30" fill="#bbdefb" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="205" y="130" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">参数解析</text>
                
                <rect x="315" y="110" width="170" height="30" fill="#bbdefb" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="400" y="130" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">清理构建目录</text>
                
                <rect x="510" y="110" width="170" height="30" fill="#bbdefb" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="595" y="130" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">收集资源文件</text>
                
                <!-- 阶段2：构建 -->
                <rect x="100" y="170" width="600" height="80" fill="#e8f5e9" rx="5" ry="5" stroke="#2e7d32" stroke-width="2"/>
                <text x="400" y="190" font-family="Arial" font-size="16" text-anchor="middle" fill="#2e7d32">构建阶段</text>
                
                <!-- 构建阶段步骤 -->
                <rect x="120" y="210" width="170" height="30" fill="#c8e6c9" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="205" y="230" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">创建PyInstaller命令</text>
                
                <rect x="315" y="210" width="170" height="30" fill="#c8e6c9" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="400" y="230" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">执行构建</text>
                
                <rect x="510" y="210" width="170" height="30" fill="#c8e6c9" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="595" y="230" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">验证构建结果</text>
                
                <!-- 阶段3：打包 -->
                <rect x="100" y="270" width="600" height="80" fill="#fff3e0" rx="5" ry="5" stroke="#e65100" stroke-width="2"/>
                <text x="400" y="290" font-family="Arial" font-size="16" text-anchor="middle" fill="#e65100">打包阶段</text>
                
                <!-- 打包阶段步骤 -->
                <rect x="150" y="310" width="220" height="30" fill="#ffe0b2" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="260" y="330" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">Windows: 创建ZIP包</text>
                
                <rect x="430" y="310" width="220" height="30" fill="#ffe0b2" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="540" y="330" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">Linux/Mac: 创建TAR.GZ包</text>
                
                <!-- 阶段4：验证 -->
                <rect x="100" y="370" width="600" height="80" fill="#f3e5f5" rx="5" ry="5" stroke="#6a1b9a" stroke-width="2"/>
                <text x="400" y="390" font-family="Arial" font-size="16" text-anchor="middle" fill="#6a1b9a">验证阶段</text>
                
                <!-- 验证阶段步骤 -->
                <rect x="150" y="410" width="220" height="30" fill="#e1bee7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="260" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">应用启动测试</text>
                
                <rect x="430" y="410" width="220" height="30" fill="#e1bee7" rx="3" ry="3" stroke="#666" stroke-width="1"/>
                <text x="540" y="430" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">基本功能验证</text>
                
                <!-- 连接线 -->
                <line x1="400" y1="150" x2="400" y2="170" stroke="#666" stroke-width="1"/>
                <polygon points="395,165 400,170 405,165" fill="#666"/>
                
                <line x1="400" y1="250" x2="400" y2="270" stroke="#666" stroke-width="1"/>
                <polygon points="395,265 400,270 405,265" fill="#666"/>
                
                <line x1="400" y1="350" x2="400" y2="370" stroke="#666" stroke-width="1"/>
                <polygon points="395,365 400,370 405,365" fill="#666"/>
                
                <!-- 平台分支 -->
                <path d="M400,290 C350,290 320,310 320,330" fill="none" stroke="#e65100" stroke-width="1" stroke-dasharray="5,2"/>
                <text x="320" y="300" font-family="Arial" font-size="10" text-anchor="middle" fill="#e65100">Windows</text>
                
                <path d="M400,290 C450,290 480,310 480,330" fill="none" stroke="#e65100" stroke-width="1" stroke-dasharray="5,2"/>
                <text x="480" y="300" font-family="Arial" font-size="10" text-anchor="middle" fill="#e65100">Linux/Mac</text>
            </svg>
        </div>
        
        <h3 id="section14-2">14.2 安装与部署指南</h3>
        <p>AI小说生成器提供多种安装与部署方式，适应不同用户的需求：</p>
        
        <div class="code">
# install.py - 安装与配置脚本

import os
import sys
import json
import shutil
import getpass
import platform
import subprocess
from pathlib import Path

def check_python_version():
    """检查Python版本"""
    min_version = (3, 8)
    current_version = sys.version_info[:2]
    
    if current_version < min_version:
        print(f"错误: 需要Python {min_version[0]}.{min_version[1]}或更高版本")
        print(f"当前版本: Python {current_version[0]}.{current_version[1]}")
        return False
    
    print(f"Python版本检查通过: {current_version[0]}.{current_version[1]}")
    return True

def check_pip():
    """检查pip是否可用"""
    try:
        subprocess.run([sys.executable, "-m", "pip", "--version"], 
                       check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("pip 检查通过")
        return True
    except subprocess.CalledProcessError:
        print("错误: pip 不可用，请先安装pip")
        return False

def install_requirements():
    """安装依赖包"""
    print("安装依赖包...")
    
    # 检查requirements.txt是否存在
    req_file = "requirements.txt"
    if not os.path.exists(req_file):
        print(f"错误: 找不到{req_file}")
        return False
    
    # 安装依赖
    try:
        result = subprocess.run([sys.executable, "-m", "pip", "install", "-r", req_file], 
                               check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("依赖包安装成功")
        return True
    except subprocess.CalledProcessError as e:
        print(f"依赖包安装失败: {e}")
        print(e.stderr.decode())
        return False

def setup_directories():
    """设置应用目录"""
    print("设置应用目录...")
    
    # 获取主目录
    home_dir = Path.home()
    
    # 创建应用目录
    app_dir = home_dir / "小说生成器"
    output_dir = app_dir / "输出"
    config_dir = app_dir / "配置"
    template_dir = app_dir / "模板"
    log_dir = app_dir / "日志"
    
    # 创建目录
    for dir_path in [app_dir, output_dir, config_dir, template_dir, log_dir]:
        dir_path.mkdir(exist_ok=True)
        print(f"已创建目录: {dir_path}")
    
    # 复制模板文件
    template_src = Path("templates")
    if template_src.exists() and template_src.is_dir():
        for template_file in template_src.glob("*.json"):
            dest_file = template_dir / template_file.name
            shutil.copy2(template_file, dest_file)
            print(f"已复制模板: {template_file.name}")
    
    # 创建默认配置
    create_default_config(config_dir)
    
    return {
        "app_dir": str(app_dir),
        "output_dir": str(output_dir),
        "config_dir": str(config_dir),
        "template_dir": str(template_dir),
        "log_dir": str(log_dir)
    }

def create_default_config(config_dir):
    """创建默认配置文件"""
    config_file = config_dir / "config.json"
    
    # 如果配置文件已存在，不覆盖
    if config_file.exists():
        print(f"配置文件已存在: {config_file}")
        return
    
    # 创建默认配置
    default_config = {
        "app": {
            "version": "1.0.0",
            "language": "zh_CN",
            "theme": "system"
        },
        "generation": {
            "default_model": "gpt-3.5-turbo",
            "default_novel_type": "奇幻冒险",
            "default_temperature": 0.7
        },
        "api": {
            "provider": "openai",
            "openai_api_key": "",
            "timeout": 60,
            "retry_count": 3
        }
    }
    
    # 写入配置文件
    with open(config_file, 'w', encoding='utf-8') as f:
        json.dump(default_config, f, ensure_ascii=False, indent=2)
    
    print(f"已创建默认配置文件: {config_file}")

def create_launcher(dirs):
    """创建启动器"""
    print("创建启动器...")
    
    if platform.system() == "Windows":
        # 在Windows上创建批处理文件
        launcher_path = Path(dirs["app_dir"]) / "启动小说生成器.bat"
        script_path = os.path.abspath(sys.argv[0])
        script_dir = os.path.dirname(script_path)
        
        launcher_content = f"""@echo off
cd /d "{script_dir}"
start pythonw main.py
"""
        
        with open(launcher_path, 'w') as f:
            f.write(launcher_content)
        
        print(f"已创建Windows启动器: {launcher_path}")
    
    elif platform.system() == "Darwin":  # macOS
        # 在macOS上创建shell脚本
        launcher_path = Path(dirs["app_dir"]) / "启动小说生成器.command"
        script_path = os.path.abspath(sys.argv[0])
        script_dir = os.path.dirname(script_path)
        
        launcher_content = f"""#!/bin/bash
cd "{script_dir}"
python3 main.py &
"""
        
        with open(launcher_path, 'w') as f:
            f.write(launcher_content)
        
        # 设置执行权限
        os.chmod(launcher_path, 0o755)
        
        print(f"已创建macOS启动器: {launcher_path}")
    
    else:  # Linux
        # 在Linux上创建shell脚本
        launcher_path = Path(dirs["app_dir"]) / "launch_novel_generator.sh"
        script_path = os.path.abspath(sys.argv[0])
        script_dir = os.path.dirname(script_path)
        
        launcher_content = f"""#!/bin/bash
cd "{script_dir}"
python3 main.py &
"""
        
        with open(launcher_path, 'w') as f:
            f.write(launcher_content)
        
        # 设置执行权限
        os.chmod(launcher_path, 0o755)
        
        print(f"已创建Linux启动器: {launcher_path}")

def setup_api_key():
    """设置API密钥"""
    print("\nAPI密钥设置 (可选)")
    print("目前支持OpenAI API")
    
    setup_key = input("是否现在设置API密钥? (y/n): ").lower() == 'y'
    if not setup_key:
        print("稍后可在应用内设置API密钥")
        return
    
    api_key = getpass.getpass("请输入OpenAI API密钥: ")
    if not api_key:
        print("未输入API密钥，跳过")
        return
    
    # 更新配置文件
    config_file = Path.home() / "小说生成器" / "配置" / "config.json"
    if config_file.exists():
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            config["api"]["openai_api_key"] = api_key
            
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            
            print("API密钥已设置")
        except Exception as e:
            print(f"无法更新配置: {e}")
    else:
        print(f"找不到配置文件: {config_file}")

def main():
    """主函数"""
    print("AI小说生成器安装程序")
    print("=====================")
    
    # 环境检查
    if not check_python_version():
        sys.exit(1)
    
    if not check_pip():
        sys.exit(1)
    
    # 安装依赖
    if not install_requirements():
        sys.exit(1)
    
    # 设置目录
    dirs = setup_directories()
    
    # 创建启动器
    create_launcher(dirs)
    
    # 设置API密钥
    setup_api_key()
    
    print("\n安装完成!")
    print(f"应用目录: {dirs['app_dir']}")
    print(f"输出目录: {dirs['output_dir']}")
    print("请使用启动器启动应用")

if __name__ == "__main__":
    main()
</div>

        <p>安装与部署分析：</p>
        <ul>
            <li><strong>环境检查</strong>：自动检查Python版本和pip可用性，确保基础环境正确。</li>
            <li><strong>依赖管理</strong>：自动安装所需依赖包，减少手动配置步骤。</li>
            <li><strong>目录结构</strong>：创建标准化的应用目录结构，确保数据分类存储。</li>
            <li><strong>配置初始化</strong>：生成默认配置文件，用户可以快速上手。</li>
            <li><strong>跨平台支持</strong>：根据不同操作系统创建适合的启动器，提升用户体验。</li>
            <li><strong>API设置</strong>：提供API密钥安全设置功能，保护用户隐私。</li>
        </ul>
    </div>
    
    <div class="page-break"></div>

    <div class="section">
        <h2 id="section15">15. 用户手册</h2>
        <h3 id="section15-1">15.1 软件使用指南</h3>
        <p>AI小说生成器是一款面向创意写作者的智能辅助工具，本手册将帮助用户快速上手使用。</p>
        
        <h4>15.1.1 基本界面</h4>
        <p>软件启动后，用户将看到以下主要界面元素：</p>
        <ul>
            <li><strong>菜单栏</strong>：包含文件、编辑、设置、帮助等常用菜单选项</li>
            <li><strong>小说类型选择</strong>：提供多种预设小说类型模板</li>
            <li><strong>参数控制面板</strong>：调整生成参数，如创意度、字数等</li>
            <li><strong>生成按钮</strong>：点击开始小说生成流程</li>
            <li><strong>状态栏</strong>：显示生成进度和系统状态</li>
        </ul>
        
        <div class="diagram">
            <svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
                <!-- 背景 -->
                <rect width="800" height="400" fill="#f9f9f9" rx="5" ry="5" stroke="#ccc" stroke-width="1"/>
                
                <!-- 标题 -->
                <text x="400" y="30" font-family="Arial" font-size="18" text-anchor="middle" fill="#333">AI小说生成器界面导图</text>
                
                <!-- 软件框架 -->
                <rect x="50" y="50" width="700" height="300" fill="#fff" rx="3" ry="3" stroke="#999" stroke-width="1"/>
                
                <!-- 菜单栏 -->
                <rect x="50" y="50" width="700" height="30" fill="#e6e6e6" rx="3" ry="3" stroke="#999" stroke-width="1"/>
                <text x="75" y="70" font-family="Arial" font-size="12" fill="#333">文件</text>
                <text x="125" y="70" font-family="Arial" font-size="12" fill="#333">编辑</text>
                <text x="175" y="70" font-family="Arial" font-size="12" fill="#333">设置</text>
                <text x="225" y="70" font-family="Arial" font-size="12" fill="#333">帮助</text>
                
                <!-- 左侧面板 -->
                <rect x="50" y="80" width="200" height="240" fill="#f0f0f0" rx="0" ry="0" stroke="#999" stroke-width="1"/>
                <text x="150" y="100" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">小说类型选择</text>
                
                <!-- 小说类型选项 -->
                <rect x="70" y="110" width="160" height="25" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <text x="150" y="127" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">奇幻冒险</text>
                
                <rect x="70" y="145" width="160" height="25" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <text x="150" y="162" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">科幻小说</text>
                
                <rect x="70" y="180" width="160" height="25" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <text x="150" y="197" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">悬疑推理</text>
                
                <rect x="70" y="215" width="160" height="25" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <text x="150" y="232" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">爱情故事</text>
                
                <rect x="70" y="250" width="160" height="25" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <text x="150" y="267" font-family="Arial" font-size="12" text-anchor="middle" fill="#333">历史传记</text>
                
                <!-- 生成设置面板 -->
                <rect x="250" y="80" width="500" height="70" fill="#f0f0f0" rx="0" ry="0" stroke="#999" stroke-width="1"/>
                <text x="500" y="100" font-family="Arial" font-size="14" text-anchor="middle" fill="#333">参数控制面板</text>
                
                <!-- 参数控制 -->
                <text x="280" y="127" font-family="Arial" font-size="12" fill="#333">创意度：</text>
                <rect x="340" y="115" width="150" height="18" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <rect x="340" y="115" width="75" height="18" fill="#4c8bf5" rx="2" ry="2" stroke="none"/>
                <circle cx="415" cy="124" r="7" fill="#fff" stroke="#666" stroke-width="1"/>
                
                <text x="530" y="127" font-family="Arial" font-size="12" fill="#333">字数：</text>
                <rect x="580" y="115" width="150" height="18" fill="#fff" rx="2" ry="2" stroke="#999" stroke-width="1"/>
                <rect x="580" y="115" width="100" height="18" fill="#4c8bf5" rx="2" ry="2" stroke="none"/>
                <circle cx="680" cy="124" r="7" fill="#fff" stroke="#666" stroke-width="1"/>
                
                <!-- 主内容区 -->
                <rect x="250" y="150" width="500" height="140" fill="#fff" rx="0" ry="0" stroke="#999" stroke-width="1"/>
                <text x="270" y="170" font-family="Arial" font-size="12" fill="#333">小说预览：</text>
                
                <!-- 预览内容 -->
                <rect x="270" y="180" width="460" height="90" fill="#f9f9f9" rx="2" ry="2" stroke="#ccc" stroke-width="1"/>
                <text x="280" y="200" font-family="Arial" font-size="10" fill="#666">这里将显示生成的小说内容...</text>
                
                <!-- 底部控制区 -->
                <rect x="50" y="320" width="700" height="30" fill="#e6e6e6" rx="0" ry="0" stroke="#999" stroke-width="1"/>
                
                <!-- 生成按钮 -->
                <rect x="270" y="325" width="100" height="20" fill="#4c8bf5" rx="10" ry="10" stroke="none"/>
                <text x="320" y="339" font-family="Arial" font-size="12" text-anchor="middle" fill="#fff">生成小说</text>
                
                <!-- 状态栏 -->
                <text x="680" y="339" font-family="Arial" font-size="10" text-anchor="end" fill="#333">就绪</text>
            </svg>
        </div>
        
        <h4>15.1.2 基本操作流程</h4>
        <ol>
            <li><strong>选择小说类型</strong>：从左侧面板选择想要生成的小说类型</li>
            <li><strong>调整参数</strong>：根据需要调整创意度、字数等参数</li>
            <li><strong>点击生成</strong>：点击"生成小说"按钮开始创作过程</li>
            <li><strong>等待生成</strong>：观察状态栏了解生成进度</li>
            <li><strong>查看结果</strong>：生成完成后在预览区查看小说内容</li>
            <li><strong>保存作品</strong>：通过"文件"菜单将作品保存到本地</li>
        </ol>
        
        <h3 id="section15-2">15.2 常见问题解答</h3>
        <div class="qa-section">
            <div class="qa-item">
                <p class="question">Q: 软件无法启动，提示"缺少依赖包"怎么办？</p>
                <p class="answer">A: 请尝试以下解决方案：</p>
                <ol>
                    <li>确认已安装正确版本的Python（3.8或更高版本）</li>
                    <li>运行安装程序中的依赖安装命令：<code>pip install -r requirements.txt</code></li>
                    <li>检查是否有防火墙或权限问题阻止软件访问必要文件</li>
                </ol>
            </div>
            
            <div class="qa-item">
                <p class="question">Q: 如何提高生成小说的质量？</p>
                <p class="answer">A: 可以尝试以下技巧：</p>
                <ul>
                    <li>调整创意度参数：较低的值会产生更连贯但可能不够创新的内容，较高的值会产生更有创意但可能逻辑性略差的内容</li>
                    <li>尝试不同的小说类型模板，找到最适合的风格</li>
                    <li>在设置中配置高级参数，如词汇多样性、结构复杂度等</li>
                    <li>使用更强大的AI模型（如果可用）</li>
                </ul>
            </div>
            
            <div class="qa-item">
                <p class="question">Q: API连接失败怎么办？</p>
                <p class="answer">A: 请检查以下几点：</p>
                <ol>
                    <li>确认API密钥是否正确输入</li>
                    <li>检查网络连接是否正常</li>
                    <li>确认API账户是否有足够余额</li>
                    <li>尝试启用"本地模式"，使用内置模型（功能有限）</li>
                </ol>
            </div>
            
            <div class="qa-item">
                <p class="question">Q: 软件支持哪些导出格式？</p>
                <p class="answer">A: 目前支持以下导出格式：</p>
                <ul>
                    <li>纯文本（.txt）</li>
                    <li>富文本（.rtf）</li>
                    <li>Word文档（.docx）</li>
                    <li>HTML网页（.html）</li>
                    <li>PDF文档（.pdf）</li>
                </ul>
            </div>
        </div>
        
        <h3 id="section15-3">15.3 快捷键参考</h3>
        <table class="shortcuts">
            <tr>
                <th>功能</th>
                <th>Windows</th>
                <th>Mac</th>
            </tr>
            <tr>
                <td>新建项目</td>
                <td>Ctrl + N</td>
                <td>⌘ + N</td>
            </tr>
            <tr>
                <td>打开文件</td>
                <td>Ctrl + O</td>
                <td>⌘ + O</td>
            </tr>
            <tr>
                <td>保存</td>
                <td>Ctrl + S</td>
                <td>⌘ + S</td>
            </tr>
            <tr>
                <td>另存为</td>
                <td>Ctrl + Shift + S</td>
                <td>⌘ + Shift + S</td>
            </tr>
            <tr>
                <td>开始生成</td>
                <td>F5</td>
                <td>F5</td>
            </tr>
            <tr>
                <td>暂停生成</td>
                <td>F6</td>
                <td>F6</td>
            </tr>
            <tr>
                <td>继续生成</td>
                <td>F7</td>
                <td>F7</td>
            </tr>
            <tr>
                <td>取消生成</td>
                <td>Esc</td>
                <td>Esc</td>
            </tr>
            <tr>
                <td>设置</td>
                <td>Ctrl + ,</td>
                <td>⌘ + ,</td>
            </tr>
            <tr>
                <td>帮助</td>
                <td>F1</td>
                <td>F1</td>
            </tr>
            <tr>
                <td>退出程序</td>
                <td>Alt + F4</td>
                <td>⌘ + Q</td>
            </tr>
            <tr>
                <td>复制</td>
                <td>Ctrl + C</td>
                <td>⌘ + C</td>
            </tr>
            <tr>
                <td>粘贴</td>
                <td>Ctrl + V</td>
                <td>⌘ + V</td>
            </tr>
            <tr>
                <td>剪切</td>
                <td>Ctrl + X</td>
                <td>⌘ + X</td>
            </tr>
            <tr>
                <td>撤销</td>
                <td>Ctrl + Z</td>
                <td>⌘ + Z</td>
            </tr>
            <tr>
                <td>重做</td>
                <td>Ctrl + Y</td>
                <td>⌘ + Shift + Z</td>
            </tr>
            <tr>
                <td>批量生成</td>
                <td>Ctrl + B</td>
                <td>⌘ + B</td>
            </tr>
            <tr>
                <td>续写小说</td>
                <td>Ctrl + R</td>
                <td>⌘ + R</td>
            </tr>
            <tr>
                <td>批量续写</td>
                <td>Ctrl + Shift + R</td>
                <td>⌘ + Shift + R</td>
            </tr>
            <tr>
                <td>自定义提示词</td>
                <td>Ctrl + P</td>
                <td>⌘ + P</td>
            </tr>
            <tr>
                <td>查找</td>
                <td>Ctrl + F</td>
                <td>⌘ + F</td>
            </tr>
            <tr>
                <td>替换</td>
                <td>Ctrl + H</td>
                <td>⌘ + H</td>
            </tr>
            <tr>
                <td>切换全屏</td>
                <td>F11</td>
                <td>⌘ + Ctrl + F</td>
            </tr>
            <tr>
                <td>导出小说</td>
                <td>Ctrl + E</td>
                <td>⌘ + E</td>
            </tr>
        </table>
    </div>

    <div class="page-break"></div>
</body>
</html> 